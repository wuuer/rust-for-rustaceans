# 第九章 不安全代码

仅仅提及“不安全代码”就常常会引起 Rust 社区以及许多旁观者的强烈反应。有些人认为这“没什么大不了的”，而另一些人则谴责这是“Rust 所有承诺都是谎言的原因”。在本章中，我希望稍微揭开神秘的面纱，解释什么是不安全代码，什么不安全，
以及如何安全地使用它。在撰写本文时，很可能在您阅读本文时，Rust 对不安全代码的具体要求仍在确定中，即使它们全部确定下来，完整的描述也超出了本书的范围。相反，我会尽力为您提供所需的构建块、直觉和工具，
帮助您在大多数不安全代码中游刃有余。

&nbsp;&nbsp;&nbsp;&nbsp;你从本章中应该学到的主要内容是：不安全代码是 Rust 为开发者提供的机制，让他们能够利用编译器无法检查的不变量。我们将探讨不安全代码是如何做到这一点的，这些不变量可能是什么，以及我们可以用它做什么。

> 不变量
>
> 在本章中，我将大量讨论不变量。不变量只是“程序正确性必须为真”的一种说法。例如，在 Rust 中，一个不变量是使用 `&` 和 `&mut` 的引用不会悬垂——它们始终指向有效值。你还可以使用特定于应用程序或库的不变量，例如“头指针始终位于尾指针之前”或“容量始终是 2 的幂”。最终，不变量代表了代码正确性所需的所有假设。然而，你可能并不总是了解代码中使用的所有不变量，而这正是 bug 潜伏的地方。

&nbsp;&nbsp;&nbsp;&nbsp;至关重要的是，不安全代码并非规避 Rust 各种规则（例如借用检查）的一种方式，而是一种使用编译器之外的推理来强制执行这些规则的方法。当你编写不安全代码时，你有责任确保生成的代码是安全的。某种程度上，当 `unsafe` 作为一个关键字用于通过 `unsafe {}` 允许不安全操作时，它会产生误导；这并不是说包含的代码是不安全的，而是因为在特定上下文中，这些操作是安全的，所以允许代码执行原本不安全的操作。

&nbsp;&nbsp;&nbsp;&nbsp;本章的其余部分分为四个部分。我们将首先简要介绍关键字本身的用法，然后探讨 `unsafe` 可以做什么。接下来，我们将讨论编写安全的 `unsafe` 代码必须遵循的规则。最后，我将提供一些关于如何安全地编写 `unsafe` 代码的建议。

## unsafe 关键词

在讨论 `unsafe` 赋予你的权力之前，我们需要先了解一下它的两种不同含义。`unsafe` 关键字在 Rust 中具有双重用途：它将特定函数标记为不安全调用，并允许你在特定代码块中调用不安全的功能。例如，示例 9-1 中的方法被标记为不安全，即使它不包含任何不安全代码。在这里，`unsafe` 关键字向调用者发出警告，指出调用 `decr` 的代码必须手动检查额外的保证。

```rust
impl<T> SomeType<T> {
 pub unsafe fn decr(&self) {
 self.some_usize -= 1;
 }
}

// 示例 9-1：仅包含安全代码的不安全方法
```

&nbsp;&nbsp;&nbsp;&nbsp;清单 9-2 演示了第二种用法。这里，方法本身没有被标记为不安全，即使它包含不安全的代码。

```rust
impl<T> SomeType<T> {
 pub fn as_ref(&self) -> &T {
 unsafe { &*self.ptr }
 }
}

// 示例 9-2：包含不安全代码的安全方法
```

&nbsp;&nbsp;&nbsp;&nbsp;这两个清单在 `unsafe` 的使用上有所不同，因为它们体现了不同的契约。`decr` 要求调用者在调用该方法时要小心谨慎，而 `as_ref` 则假定调用者在调用其他 unsafe 方法（如 `decr`）时非常谨慎。为了理解原因，假设 `SomeType` 实际上是像 `Rc` 这样的引用计数类型。即使 `decr` 只减少一个数字，但该减少操作也可能通过安全方法 `as_ref` 触发未定义的行为。如果调用 `decr`，然后删除给定 `T` 的倒数第二个 `Rc`，则引用计数将降至零，并且该 `T` 将被删除——但程序可能仍会在最后一个 `Rc` 上调用 `as_ref`，最终得到一个悬垂引用。

> 未定义行为描述的是程序在运行时违反语言不变量的后果。一般来说，如果程序触发了未定义行为，其结果将完全无法预测。我们将在本章后面更详细地讨论未定义行为。

&nbsp;&nbsp;&nbsp;&nbsp;相反，只要无法使用安全代码破坏 `Rc` 的引用计数，那么像 `as_ref` 的代码那样，在 `Rc` 内部解引用指针始终是安全的——`&self` 的存在证明该指针仍然有效。我们可以利用这一点，为调用者提供一个安全的 API，以应对原本不安全的操作，这是负责任地使用 `unsafe` 的核心原则。

&nbsp;&nbsp;&nbsp;&nbsp;由于历史原因，Rust 中每个不安全 `fn` 都包含一个隐式的不安全块。也就是说，如果你声明了一个不安全 `fn`，你始终可以在该 `fn` 中调用任何不安全方法或原始操作。然而，这一决定现在被认为是一个错误，并且正在通过已被接受和实施的 RFC 2585 进行撤销。该 RFC 警告说，如果一个不安全 fn 在没有显式不安全块的情况下执行不安全操作，那么 lint 也可能会在未来的 Rust 版本中变成硬错误。这样做的目的是为了减少“盲区半径”——如果每个不安全 `fn` 都是一个巨大的不安全块，那么你可能会在不知不觉中意外执行不安全操作！例如，在示例 9-1 中的 decr 中，在当前规则下，你也可以添加 `*std::ptr::null()` 而不使用任何不安全注解。

&nbsp;&nbsp;&nbsp;&nbsp;区分 `unsafe` 作为标记和 `unsafe` 块作为启用 `unsafe` 操作的机制非常重要，因为你必须以不同的方式思考它们。`unsafe fn` 会向调用者表明，他们在调用相关 `fn` 时必须小心谨慎，并且必须确保函数记录的安全不变量成立。

&nbsp;&nbsp;&nbsp;&nbsp;同时，不安全块意味着编写该块的人仔细检查了其中执行的任何不安全操作的安全不变量是否成立。如果想要一个近似的现实世界类比，`unsafe fn` 是一个未签名的契约，要求调用代码的作者“庄严宣誓 X、Y 和 Z”。同时，`unsafe {}` 是调用代码的作者签署了块中包含的所有不安全契约。在我们学习本章的其余部分时，请记住这一点。

## 强大的权限

那么，一旦你用 `unsafe {}` 签署了不安全契约，你还能做什么呢？说实话，能做的不多。或者说，它并没有启用那么多新功能。在不安全代码块中，你可以解引用原始指针并调用`unsafe fns`。

&nbsp;&nbsp;&nbsp;&nbsp;就是这样。从技术上讲，你还可以做其他一些事情，比如访问可变变量和外部静态变量，以及访问联合体的字段，但这些对讨论的影响不大。说实话，这就足够了。这些能力加在一起，可以让你制造各种混乱，比如用 `mem::transmute` 将类型转换为另一种类型，解引用指向未知位置的原始指针，将 `&'a` 强制转换为 `&'static`，或者让类型即使它们不是线程安全的，也能跨线程共享。

&nbsp;&nbsp;&nbsp;&nbsp;在本节中，我们不会过多担心这些能力可能带来的问题。我们会把这个问题留到后面那个无聊、负责任、成熟的部分。相反，我们会看看这些闪亮的新玩具，以及它们能做什么。

### 处理原始指针

使用 `unsafe` 的一个最根本原因是为了处理 Rust 的原始指针类型：`*const T` 和 `*mut T`。你可以将它们视为与 `&T` 和 `&mut T` 类似，只是它们没有生命周期，并且不受与 `&` 类型相同的有效性规则约束（我们将在本章后面讨论）。这些类型可以互换地称为指针和原始指针，主要是因为许多开发人员本能地将引用称为指针，而称它们为原始指针可以使区别更加清晰。

&nbsp;&nbsp;&nbsp;&nbsp;由于 `*` 适用的规则比 `&` 少，因此即使在 `unsafe` 块之外，你也可以将引用强制转换为指针。只有当你想反过来，从 `*` 转换为 `&` 时，才需要 `unsafe` 操作符。通常，你会将指针转换回引用，以便对指向的数据执行一些有用的操作，例如读取或修改其值。因此，指针上常用的操作是 `unsafe { &*ptr }` （或 `&mut *`）。这里的 `*` 可能看起来很奇怪，因为代码只是构造了一个引用，而不是解引用指针，但如果你看一下类型，就会明白其中的道理；如果你有一个 `*mut T` 并且想要一个 `&mut T`，那么 `&mut ptr`只会返回一个 `&mut *mut T`。你需要 `*` 来表明你想要的是 `ptr` 指针指向的可变引用。

> 指针类型
>
> 您可能想知道 `*mut T`、`*const T` 和 `std::ptr::NonNull<T>` 之间有什么区别。确切的规范仍在制定中，但 `*mut T` 和 `*const T`/`NonNull<T>` 之间主要的实际区别在于 `*mut T` 在 `T` 中是不变的（参见第一章的“生命周期变异”），而其他两个是协变的。顾名思义，`*const T` 和`NonNull<T>` 的主要区别在于 `NonNull<T>` 不允许为空指针，而 `*const T` 可以。
> 我在这些类型中进行选择的最佳建议是，如果你能够指定相关的生命周期，凭直觉判断你会写成 `&mut` 还是 `&`。如果你会写 `&`，并且你知道指针永远不会为空，那么请使用 `NonNull<T>`。它得益于一种名为“利基优化”的出色优化：基本上，由于编译器知道该类型永远不会为空，因此它可以使用该信息来表示像 `Option<NonNull<T>>` 这样的类型，而无需任何额外开销，因为 `None` 的情况可以通过将 `NonNull` 设置为空指针来表示！空指针值在 `NonNull<T>` 类型中是一个利基。如果指针可能为空，请使用 `*const T`。如果你会写 `&mut T`，请使用 `*mut T`。

### 无法表示的生命周期

由于原始指针没有生命周期，因此它们可以用于指向值的活跃度无法在 Rust 的生命周期系统中静态表达的情况，例如，像我们在第 8 章讨论过的生成器那样的自引用结构体中的自指针。指向 `self` 的指针在 `self` 存在期间有效（并且不会移动，这就是 `Pin` 的作用），但这不是通常可以命名的生命周期。虽然整个自引用类型可能是“静态的”，但自指针不是——如果它是静态的，那么即使你把这个指针给了别人，他们也可以永远使用它，即使在 `self` 消失之后！以示例 9-3 中的类型为例；这里我们尝试将构成值的原始字节与其存储的表示一起存储。

```rust
struct Person<'a> {
 name: &'a str,
 age: usize,
}
struct Parsed {
 bytes: [u8; 1024],
 parsed: Person<'???>,
}

// 示例 9-3：尝试命名自引用的生命周期，但失败了
```

&nbsp;&nbsp;&nbsp;&nbsp;`Person` 内部的引用想要引用 `Parsed` 中以字节形式存储的数据，但 `Parsed` 中没有可以分配给该引用的生命周期。它不是 '`static`' 或类似 '`self`'（后者不存在）的类型，因为如果`Parsed` 被移动，该引用就不再有效。

&nbsp;&nbsp;&nbsp;&nbsp;由于指针没有生命周期，它们规避了这个问题，因为你不必能够命名生命周期。相反，你只需确保当你使用指针时，它仍然有效，这就是你在写 `unsafe { &*ptr }` 时所承诺的。在示例 9-3 的例子中，Person 会存储一个 `*const str`，然后在适当的时候，在能够保证指针仍然有效的情况下，将其不安全地转换为 `&str`。

&nbsp;&nbsp;&nbsp;&nbsp;类似的问题也出现在像 `Arc` 这样的类型上，它有一个指向值的指针，该值在一段时间内共享，但这段时间只有在运行时，最后一个 `Arc` 被释放时才可知。这个指针有点像“静态”，但实际上并非如此——就像在自引用的情况下，当最后一个 `Arc` 引用消失时，指针就不再有效，所以它的生命周期更像是“自身”。在 `Arc` 的“表亲”`Weak` 中，它的生命周期也是“当最后一个 `Arc` 消失时”，但由于 `Weak` 不是 `Arc`，所以它的生命周期甚至与自身无关。因此，`Arc` 和 `Weak` 都在内部使用原始指针。

### 指针运算

使用原始指针，你可以像在 C 语言中一样进行任意指针运算，通过使用 `.offset()`、`.add()` 和 `.sub()` 将指针移动到同一分配空间内的任意字节。这最常用于高度空间优化的数据结构，例如哈希表，在这些结构中，为每个元素存储一个额外的指针会增加过多的开销，并且无法使用切片。这些都是相当小众的用例，本书不会详细讨论，但如果你想了解更多信息，我鼓励你阅读 hashbrown::RawTable 的代码 (https://github.com/rust-lang/hashbrown/)！

&nbsp;&nbsp;&nbsp;&nbsp;即使你不想在调用指针后将其转换为引用，调用指针运算方法也是不安全的。造成这种情况的原因有很多，但最主要的是，将指针指向其原始指向的分配空间末尾之外是非法的。这样做会触发未定义的行为，编译器可以决定吞噬你的代码，并将其替换为只有编译器才能理解的任意代码。如果你确实使用这些方法，请仔细阅读文档！

#### 转换到指针然后再转换回来

通常，当你需要使用指针时，是因为你有一些普通的 Rust 类型，例如引用、切片或字符串，而你必须暂时过渡到指针的世界，然后再返回到原始的普通类型。因此，一些关键的标准库类型提供了将它们转换为原始组成部分（例如切片的指针和长度）的方法，以及使用这些部分将它们转换回完整部分的方法。例如，你可以使用 `as_ptr` 获取切片的数据指针，使用 `[]::len` 获取其长度。然后，你可以通过将这些相同的值提供给 `std::slice::from_raw_parts` 来重建切片。`Vec`、`Arc` 和 `String` 具有类似的方法，它们返回指向底层分配的原始指针，而 `Box` 具有 `Box::into_raw` 和`Box::from_raw`，它们执行相同的操作。

#### 玩转类型

有时，你有一个类型 `T`，并希望将其视为另一个类型 `U`。无论这是因为你需要进行闪电般的零拷贝解析，还是因为你需要调整一些生命周期，Rust 都为你提供了一些（非常不安全的）工具来实现。

&nbsp;&nbsp;&nbsp;&nbsp;其中第一个也是迄今为止最广泛使用的就是指针强制转换：你可以将一个 `*const T` 强制转换为任何其他 `*const U`（`mut` 也是如此），甚至不需要 `unsafe` 即可执行此操作。只有当你稍后尝试将强制转换后的指针用作引用时，这种不安全性才会发挥作用，因为你必须断言原始指针实际上可以用作其指向类型的引用。

&nbsp;&nbsp;&nbsp;&nbsp;这种指针类型转换在使用外部函数接口 (`FFI`) 时尤其方便——你可以将任何 Rust 指针转换为 `*const std::ffi::c_void` 或 `*mut std::ffi::c_void`，然后将其传递给需要 `void` 指针的 C 函数。同样，如果你从 C 语言中获取了一个 `void` 指针，并且之前传入了它，你可以轻松地将其转换回其原始类型。

&nbsp;&nbsp;&nbsp;&nbsp;当你想将字节序列解释为普通数据类型（例如整数、布尔值、字符和数组，或这些类型的 `#[repr(C)]` 结构体）时，指针强制转换也很有用，或者直接将这些类型写成字节流而不进行序列化。如果你想尝试这样做，需要记住许多安全不变量，但我们稍后再讨论。

### 调用不安全函数

可以说，`unsafe` 最常用的功能是它允许你调用不安全的函数。在堆栈的深层，大多数此类函数是不安全的，因为它们在某些基本层面上操作的是原始指针；但在堆栈的更高层，你往往主要通过函数调用来与不安全函数交互。

&nbsp;&nbsp;&nbsp;&nbsp;调用不安全函数所能实现的功能实际上没有限制，因为这完全取决于你与之交互的库。但总的来说，不安全函数可以分为三类：与非 Rust 接口交互的函数、跳过安全检查的函数，以及具有自定义不变量的函数。

#### 外部函数接口

Rust 允许你使用 `extern` 块（我们将在第 11 章详细讨论）声明在 Rust 以外的语言中定义的函数和静态变量。声明这样的块，实际上是在告诉 Rust，其中出现的项将在最终程序二进制文件链接时由某个外部源（例如，你正在集成的 C 库）实现。由于 `extern` 块不受 Rust 控制，因此访问它们本质上是不安全的。如果你在 Rust 中调用一个 C 函数，那么一切都将不保——它可能会覆盖你的整个内存内容，并将你所有整齐排列的引用破坏成指向内核某个位置的随机指针。同样，`extern` 静态变量可能随时被外部代码修改，并且可能被填充各种与其声明类型完全不符的错误字节。不过，在不安全的块中，你可以随心所欲地访问外部变量，只要你愿意保证外部变量的另一方遵守 Rust 的规则。

#### 我会通过安全检查

通过引入额外的运行时检查，一些不安全的操作可以变得完全安全。例如，访问切片中的项是不安全的，因为您可能会尝试访问超出切片长度的项。但是，考虑到这种操作的常见性，如果对切片进行索引操作不安全，那就太可惜了。因此，安全的实现包含边界检查，如果提供的索引超出范围，则（取决于您使用的方法）会引发 `panic` 或返回 `Option`。这样，即使您传入的索引超出了切片的长度，也不会导致未定义的行为。另一个例子是哈希表，它会对您提供的键进行哈希处理，而不是让您自己提供哈希值；这确保您永远不会尝试使用错误的哈希值访问键。

&nbsp;&nbsp;&nbsp;&nbsp;然而，在对极致性能的无休止追求中，一些开发者可能会发现这些安全检查在他们最紧凑的循环中增加了过多的开销。为了满足峰值性能至关重要且调用者知道索引在边界内的情况，许多数据结构提供了不包含这些安全检查的特定方法的替代版本。这些方法的名称中通常会包含 `unchecked` 一词，以表明它们盲目地信任所提供的参数是安全的，并且不会执行任何令人讨厌且缓慢的安全检查。例如，`NonNull::new_unchecked`、`slice::get_unchecked`、`NonZero::new_unchecked`、`Arc::get_mut_unchecked` 和 `str::from_utf8_unchecked`。

&nbsp;&nbsp;&nbsp;&nbsp;实践中，未经检查的方法在安全性和性能方面的权衡很少值得。性能优化的原则是先测量，再优化。

#### 自定义不变量

大多数 `unsafe` 函数的使用都在一定程度上依赖于自定义的不变量。也就是说，它们依赖于 Rust 自身提供的不变量，这些不变量特定于特定的应用程序或库。由于许多函数都属于此类，因此很难对这类 `unsafe` 函数进行很好的概括。因此，我将提供一些您在实践中可能会遇到并希望使用的带有自定义不变量的 unsafe 函数的示例：

##### MaybeUninit::assume_init

`MaybeUninit` 类型是 Rust 中少数几种可以存储其类型无效值的方式之一。你可以将 `MaybeUninit<T>` 视为一个 T，但目前可能不合法地用作 T。
例如，`MaybeUninit<NonNull>` 可以保存空指针，`MaybeUninit<Box>` 可以保存悬空堆指针，而 `MaybeUninit<bool>` 可以保存数字 3 的位模式（通常必须为 0 或 1）。如果你正在逐位构造值，或者处理最终会变为有效的零值或未初始化内存（例如通过调用 `std::io::Read::read` 进行填充），那么 `MaybeUninit` 会非常方便。`assume_init` 函数断言 `MaybeUninit` 现在保存了类型 T 的有效值，因此可以用作 `T`。

##### ManuallyDrop::drop

`ManuallyDrop` 类型是类型 `T` 的包装器类型，当 `ManuallyDrop` 被丢弃时，它不会丢弃该 `T`。或者换句话说，它将外部类型（`ManuallyDrop`）的丢弃与内部类型（`T`）的丢弃解耦。它通过 `DerefMut<Target = T>` 实现了对 `T` 的安全访问，同时还提供了一个 `drop` 方法（独立于 `Drop trait` 的 `drop` 方法），用于丢弃包装的 `T` 而不丢弃 `ManuallyDrop`。也就是说，`drop` 函数即使丢弃了 `T`，也会接受 `&mut self` ，因此会留下 `ManuallyDrop`。如果您必须显式丢弃一个无法移动的值（例如在 `Drop trait` 的实现中），这会非常方便。一旦该值被丢弃，尝试访问该 `T` 就不再安全，这就是为什么 `drop` 调用是不安全的——它断言该 `T` 永远不会被再次访问。

##### std::ptr::drop_in_place

`drop_in_place` 允许你通过指向该值的指针直接调用该值的析构函数。这种方法并不安全，因为调用后，指针指向的对象会被遗留，所以如果之后某些代码尝试取消引用该指针，就会遇到麻烦！当你需要重用内存（例如在 `arena` 分配器中），并且需要就地丢弃旧值而不回收其周围的内存时，此方法尤其有用。

##### Waker::from_raw

在第八章中，我们讨论了 `Waker` 类型，以及它是如何由一个数据指针和一个包含手动实现的虚函数表 (vtable) 的 `RawWaker` 组成的。一旦 `Waker` 被构造，虚函数表中的原始函数指针（例如 `wake` 和 `drop`）就可以从安全代码中调用（分别通过 `Waker::wake` 和 `drop(waker)`）。异步执行器在 `Waker::from_raw` 中断言其虚函数表中的所有指针都是有效的函数指针，并且遵循 `RawWakerVTable` 文档中规定的契约。

##### std::hint::unreachable_unchecked

`hint` 模块包含一些函数，它们会向编译器提供有关周围代码的提示，但实际上不会生成任何机器码。`unreachable_unchecked` 函数会特别告知编译器，程序在运行时不可能到达某段代码。这反过来又允许编译器基于这些知识进行优化，例如消除指向该位置的条件分支。与 `unreachable!` 宏不同，如果代码确实到达了该行，它就会引发`panic`，而错误的 `unreachable_unchecked` 函数的影响则难以预测。编译器优化可能会导致一些奇怪且难以调试的行为，更不用说你的程序会在它认为正确的事情实际上并非如此时继续运行！

##### std::ptr::{read,write}_{unaligned,volatile}

`ptr` 模块包含许多函数，可用于处理奇数指针——即那些不符合 Rust 通常对指针的假设的指针。第一个函数是 `read_unaligned` 和 `write_unaligned`，它们允许您访问指向 `T` 的指针，即使该 T 未按照其对齐方式存储（参见第二章关于对齐的部分）。如果 `T` 直接包含在字节数组中，或者与其他值打包在一起而没有进行适当的填充，则可能会发生这种情况。第二个值得注意的函数是`read_volatile` 和 `write_volatile`，它们允许您操作不指向普通内存的指针。具体来说，这些函数将始终访问给定的指针（例如，即使您连续两次读取同一个指针，它们也不会被缓存在寄存器中），并且编译器不会将 `volatile` 访问相对于其他 `volatile` 访问进行重新排序。当使用不受普通 DRAM 内存支持的指针时，易失性操作非常方便——我们将在第 11 章进一步讨论这一点。最终，这些方法是不安全的，因为它们会取消引用给定的指针（并且指向一个拥有的 `T`），因此作为调用者，您需要签署与此相关的所有合同。

##### std::thread::Builder::spawn_unchecked

我们熟知并喜爱的普通 `thread::spawn` 要求提供的闭包是“静态”的。这种限制源于这样一个事实：生成的线程可能运行一段不确定的时间；如果我们被允许使用对调用者堆栈的引用，调用者
可能会在生成的线程退出之前就返回，从而导致引用无效。然而，有时你知道调用者中的某些非“静态”值会比生成的线程存活得更久。如果你在丢弃相关值之前加入线程，或者在确定生成的线程将不再使用该值之后才严格丢弃该值，就可能会发生这种情况。这就是 `spawn_unchecked` 的用武之地——它没有“静态”的限制，因此允许你实现这些用例，只要你愿意签署协议，保证不会因此发生不安全的访问。不过，要小心`panic`；如果调用者崩溃，它可能会比你计划的更早地丢弃值，并导致生成的线程中出现未定义的行为！

请注意，所有这些方法（实际上，标准库中的所有不安全方法）都为其安全不变量提供了明确的文档，任何不安全方法都应如此。

## 实现不安全的trait

不安全`trait`并非使用不安全，而是实现不安全。这是因为不安全代码可以依赖于不安全`trait`实现的正确性（由`trait`文档定义）。例如，要实现不安全`trait` `Send`，您需要编写 `unsafe impl Send for ...`。与不安全函数一样，不安全特征通常具有自定义不变量，这些不变量在`trait`文档中指定（或至少应该指定）。因此，很难将不安全`trait`作为一个整体进行介绍，因此在这里，我也将给出一些来自标准库的常见示例，这些示例值得一读。

### Send and Sync

`Send` 和 `Sync` `trait` 分别表示某个类型可以安全地跨线程发送或共享。我们将在第 10 章中详细讨论这些 `trait`，但现在您需要知道的是，它们是自动 `trait`，因此编译器通常会为大多数类型实现它们。但是，与自动 `trait` 的情况一样，如果相关类型的任何成员本身不是 `Send` 或 `Sync` `trait`，则不会实现 `Send` 和 `Sync` `trait`。

&nbsp;&nbsp;&nbsp;&nbsp;在不安全代码的上下文中，这个问题主要源于原始指针，它既不是 `Send` 也不是 `Sync`。乍一看，这似乎很合理：编译器无法知道还有谁可能拥有指向相同值的原始指针，也不知道他们此刻可能如何使用它，那么，这种类型如何才能安全地跨线程发送呢？不过，既然我们都是经验丰富的不安全开发人员，这个论点似乎站不住脚——毕竟，解引用原始指针本身就已经不安全了，那么处理 `Send` 和 `Sync` 的不变量又有什么不同呢？

&nbsp;&nbsp;&nbsp;&nbsp;严格来说，原始指针可以同时支持 `Send` 和 `Sync` 操作。问题在于，如果是这样，包含原始指针的类型本身将自动支持 `Send` 和 `Sync` 操作，即使它们的作者可能没有意识到这一点。这样一来，开发人员可能会不安全地取消引用原始指针，而从未考虑过如果这些类型跨线程发送或共享会发生什么，从而无意中引入未定义的行为。因此，原始指针类型会阻止这些自动实现，作为对不安全代码的额外保护，以确保作者明确签署协议，声明他们也遵循了 `Send` 和 `Sync` 的不变量。

> `Send` 和 `Sync` 的不安全实现的一个常见错误是忘记为泛型参数添加边界：`unsafe impl<T: Send> Send for MyUnsafeType<T> {}`。

### GlobalAlloc

`GlobalAlloc` `trait` 是在 Rust 中实现自定义内存分配器的方法。本书不会过多讨论这个话题，但这个 `trait` 本身很有趣。示例 9-4 给出了 `GlobalAlloc` `trait` 所需的方法。

```rust
pub unsafe trait GlobalAlloc {
 pub unsafe fn alloc(&self, layout: Layout) -> *mut u8;
 pub unsafe fn dealloc(&self, ptr: *mut u8, layout: Layout);
}

// 示例 9-4：GlobalAlloc trait 及其所需方法
```

该特征的核心是，它有一个用于分配新内存块的方法 `alloc`，以及一个用于释放内存块的方法 `dealloc`。`Layout` 参数描述了类型的大小和对齐方式，正如我们在第二章中讨论过的。每个方法都是不安全的，并且带有一些调用者必须遵守的安全不变量。

`GlobalAlloc` 本身也是不安全的，因为它限制的是`trait`的实现者，而不是其方法的调用者。只有`trait`的不安全性才能确保实现者同意遵守 Rust 自身对其内存分配器所假设的不变量，例如标准库中 `Box` 的实现。如果`trait`本身并非不安全，实现者可以安全地实现 `GlobalAlloc`，但会产生未对齐的指针或大小不正确的分配，这会在原本安全的代码中触发不安全性，因为这些代码假设分配是合理的。这将违反安全代码不应触发其他安全代码中的内存不安全性的规则，从而造成各种混乱。

### 竟然不是 Unpin

`Unpin` `trait` 并非不安全，这或许会让许多 Rust 开发者感到意外。读完第八章之后，你甚至可能会感到意外。毕竟，该 `trait` 旨在确保自引用类型在建立内部指针后（即被放入 `Pin` 后）被移动时不会失效。因此，`Unpin` 可以用来安全地从 `Pin` 中移除类型，这似乎有些奇怪。

`Unpin` 并非不安全 `trait`，主要有两个原因。首先，它没有必要。为你控制的类型实现 `Unpin` 并不意味着你能够安全地固定或取消固定 `!Unpin` 类型；这仍然需要调用 `Pin::new_unchecked` 或 `Pin::get_unchecked_mut` 来实现不安全机制。其次，你已经有一种安全的方法可以取消固定你控制的任何类型：`Drop trait！`当你为某个类型实现 `Drop` 时，即使你的类型之前存储在 `Pin` 中并且是 `!Unpin` 类型的，你也会被传递 `&mut self` ，所有这些都不会带来任何不安全。这种不安全的可能性被 `Pin::new_unchecked` 的不变量所覆盖，因此，创建这种 `!Unpin` 类型的 `Pin` 时必须首先遵循这些不变量。

### 何时使trait变为Unsafe

虽然目前已知的不安全`trait`很少，但所有不安全的`trait`都遵循相同的模式。如果安全代码假设该`trait`已正确实现，而该`trait`未正确实现时却可能出现内存不安全，则该`trait`应该是不安全的。

&nbsp;&nbsp;&nbsp;&nbsp;`Send` `trait` 是一个很好的例子，需要牢记——安全代码可以轻松地创建一个线程并将值传递给该线程，但如果 `Rc` 是不安全代码`Send`，那么这一系列操作很容易导致内存不安全。想象一下，如果你克隆一个 `Rc<Box>` 并将其发送给另一个线程会发生什么：这两个线程很容易同时尝试释放 `Box`，因为它们没有正确同步对 `Rc` 引用计数的访问。

&nbsp;&nbsp;&nbsp;&nbsp;`Unpin` `trait`就是一个很好的反例。虽然有可能编写出不安全的代码，如果 `Unpin` 实现不正确，就会触发内存不安全，但没有任何完全安全的代码会因为 `Unpin` 的实现而触发内存不安全。确定一个`trait`是否安全并不总是那么容易，（事实上，`Unpin` 特质在 RFC 的大部分流程中都是不安全的），但你总是可以先将其设置为不安全，然后在意识到情况确实如此后再将其设置为安全！只需记住，这是一个向后不兼容的更改。

&nbsp;&nbsp;&nbsp;&nbsp;还要记住，仅仅因为感觉某个`trait`的错误（甚至是恶意的）实现会造成很大的破坏，并不一定是将其标记为不安全的充分理由。不安全标记首先应该用于突出显示内存不安全的情况，而不仅仅是可能触发业务逻辑错误的某些情况。例如，`Eq`、`Ord`、`Deref` 和 `Hash` 特征都是安全的，即使世界上可能有很多代码在遇到恶意实现（例如，每次调用都会返回不同随机哈希值的 `Hash` 实现）时会崩溃。这也适用于不安全代码——几乎可以肯定存在内存不安全的不安全代码，在存在这样的 `Hash` 实现的情况下——但这并不意味着 `Hash` 应该是不安全的。同样，每次解引用到不同（但有效）目标的 `Deref` 实现也是如此。这种不安全的代码依赖于实际上并不成立的 `Hash` 或 `Deref` 契约；`Hash` 从未声称它是确定性的，`Deref` 也是如此。或者更确切地说，这些实现的作者从未使用 `unsafe` 关键字来做出这种声明！

> `Eq`、`Hash` 和 `Deref` 等 `trait` 之所以安全，一个重要含义是：不安全代码只能依赖于安全代码的安全性，而不能依赖于其正确性。这不仅适用于 `trait`，也适用于所有不安全/安全代码的交互。

# 重大的责任

到目前为止，我们主要讨论了允许使用不安全代码执行的各种操作。但是，不安全代码只有在安全地执行这些操作的情况下才被允许执行这些操作。即使不安全代码可以解引用原始指针，它也必须仅在知道该指针在当时作为其指向对象的引用有效的情况下才能执行此操作，并且必须遵守 Rust 对引用的所有常规要求。换句话说，不安全代码可以访问可用于执行不安全操作的工具，但它必须使用这些工具只能执行安全的操作。

&nbsp;&nbsp;&nbsp;&nbsp;那么，这就引出了一个问题：安全究竟意味着什么？什么时候解引用指针是安全的？什么时候在两种不同类型之间转换是安全的？在本节中，我们将探讨在使用 `unsafe` 时需要牢记的一些关键不变量，看看一些常见的陷阱，并熟悉一些帮助你编写更安全的 `unsafe` 代码的工具。

&nbsp;&nbsp;&nbsp;&nbsp;关于 Rust 代码安全的具体规则仍在制定中。在撰写本文时，不安全代码指南工作组正在努力明确所有应该做和不应该做的事情，但许多问题仍未得到解答。本节中的大部分建议已基本确定，但我会指出任何尚未确定的建议。无论如何，我希望本节能够教会您在编写不安全代码时谨慎做出假设，并提醒您在声明代码可用于生产环境之前仔细检查 Rust 参考资料。

## 可能出现什么问题？

如果不讨论违反这些规则会发生什么，我们就无法真正理解不安全代码必须遵守的规则。假设你同时从多个线程可变地访问一个值，构造一个未对齐的引用，或者取消引用一个悬垂指针——现在该怎么办？

&nbsp;&nbsp;&nbsp;&nbsp;并非绝对安全的不安全代码被称为具有未定义行为。未定义行为通常以三种方式之一表现出来：完全不安全、通过可见的错误或通过不可见的损坏。第一种是幸运的情况——你编写了一些真正不安全的代码，但编译器生成了正常的代码，并且在运行这些代码的计算机上能够以正常的方式执行。不幸的是，这种幸运非常脆弱。如果出现一个新的、稍微智能一些的编译器版本，或者一些相关的代码导致编译器应用了另一种优化，代码可能不再执行正常的操作，并陷入更糟糕的情况。即使相同的代码由相同的编译器编译，如果它在不同的平台或主机上运行，程序的行为可能会有所不同！这就是为什么即使一切目前看起来运行良好，也要避免未定义行为的原因。不这样做就像仅仅因为你在第一轮俄罗斯轮盘赌中幸存下来就玩第二轮一样。

&nbsp;&nbsp;&nbsp;&nbsp;可见错误是最容易捕获的未定义行为。例如，如果你解引用一个空指针，你的程序（很有可能）会崩溃并出现错误，然后你可以通过调试找到根本原因。调试本身可能很困难，但至少你会收到一个通知，告诉你哪里出错了。可见错误也可能以不太严重的方式表现出来，例如死锁、输出乱码或打印出来但不会触发程序退出的`panic`，所有这些都告诉你代码中有一个错误，你必须去修复。

&nbsp;&nbsp;&nbsp;&nbsp;未定义行为最糟糕的表现是，虽然没有立即可见的影响，但程序状态却受到了不可见的破坏。交易金额可能与应有值略有偏差，备份可能悄无声息地被破坏，或者内部内存的随机位可能暴露给外部客户端。未定义行为可能导致持续的损坏，或极少发生的中断。未定义行为的部分挑战在于，顾名思义，非安全代码的行为是未定义的——编译器可能会完全消除它，彻底改变代码的语义，甚至错误编译周围的代码。这对程序的影响完全取决于相关代码的作用。未定义行为的不可预测的影响，正是所有未定义行为都应被视为严重错误的原因，无论其当前表现如何。

> 为什么行为不明确？
>
> &nbsp;&nbsp;&nbsp;&nbsp;在关于未定义行为的讨论中，经常出现的一个论点是：如果代码表现出未定义行为，编译器应该发出错误，而不是做一些奇怪且不可预测的事情。这样一来，编写糟糕的不安全代码就几乎不可能了！
> &nbsp;&nbsp;&nbsp;&nbsp;不幸的是，这是不可能的，因为未定义行为很少是明确或显而易见的。相反，通常的情况是，编译器只是假设代码遵循规范，并应用优化。如果事实并非如此——这种情况在运行时才会清晰——则很难预测会产生什么效果。也许优化仍然有效，不会发生任何不良后果；但也许并非如此，最终代码的语义与未优化版本略有不同。
> &nbsp;&nbsp;&nbsp;&nbsp;如果我们告诉编译器开发者，他们不允许对底层代码进行任何假设，那么我们实际上是在告诉他们，他们无法执行目前已经非常成功的各种优化。几乎所有复杂的优化都会根据语言规范，对相关代码可以做什么、不能做什么做出假设。
> &nbsp;&nbsp;&nbsp;&nbsp;如果您想更好地了解规范和编译器优化如何以奇怪的方式相互作用，并且难以归咎，我建议您阅读 Ralf Jung 的博客文章“我们需要更好的语言规范”(https://www.ralfj.de/blog/2020/12/14/provenance.html)。

## 有效性

在编写不安全代码之前，或许最重要的概念是理解有效性，它规定了哪些值存在于给定类型中的规则——或者，通俗地说，是类型值的规则。这个概念听起来很简单，所以让我们深入研究一些具体的例子。

### 引用类型

Rust 对于其引用类型可以保存的值非常严格。具体来说，引用绝不能悬空，必须始终对齐，并且必须始终指向其目标类型的有效值。此外，对给定内存位置的共享引用和独占引用绝不能同时存在，对同一位置的多个独占引用也不能同时存在。无论您的代码是否使用这些引用，这些规则都适用——您不能创建空引用，即使您随后立即将其丢弃！

&nbsp;&nbsp;&nbsp;&nbsp;共享引用有一个额外的约束，即被指向的对象在其生命周期内不得更改。也就是说，被指向的对象所包含的任何值在其生命周期内都必须保持完全相同。这适用于传递性引用，因此，如果您对包含 `*mut T` 的类型使用 `&` 运算符，则您永远无法通过该 `*mut` 修改 `T`，即使您可以编写代码使用 `unsafe` 来实现。此规则的唯一例外是 `UnsafeCell` 类型包装的值。所有其他提供内部可变性的类型，例如 `Cell`、`RefCell` 和 `Mutex`，都在内部使用 `UnsafeCell`。

&nbsp;&nbsp;&nbsp;&nbsp;Rust 对引用的严格规则导致了一个有趣的结果：多年来，使用 `repr(Rust)` 无法安全地获取对已打包或部分未初始化结构体的字段的引用。由于 `repr(Rust)` 会保留未定义类型的布局，因此获取字段地址的唯一方法是将 `&some_struct.field` 写为 `*const _`。但是，如果 `some_struct` 是已打包的，那么 `some_struct.field` 可能未对齐，因此创建指向它的 `&` 是非法的！此外，如果 `some_struct` 未完全初始化，那么 `some_struct` 引用本身就不存在！在 Rust 1.51.0 中，`ptr::addr_of!` 宏得到了稳定，增加了一种无需先创建引用即可直接获取字段引用的机制，从而解决了这个问题。在 Rust 内部，它使用一种称为原始引用（不要与原始指针混淆）的东西来实现，它直接创建指向其操作数的指针，而不是通过引用。原始引用在 RFC 2582 中引入，但截至撰写本文时尚未稳定。

### 原始类型

Rust 的一些原始类型对其可保存的值有限制。例如，bool 类型被定义为 1 个字节，但只能保存 0x00 或 0x01；char 类型则不能保存代理值或大于 char::MAX 的值。Rust 的大多数原始类型，实际上 Rust 的大多数类型，也不能从未初始化的内存中构造。这些限制看似随意，但通常也源于实现原本无法实现的优化的需求。

&nbsp;&nbsp;&nbsp;&nbsp;一个很好的例子就是利基优化（niche Optimization），我们在本章前面讨论指针类型时简要讨论过。总结一下，利基优化在某些情况下会将枚举判别值隐藏在包装类型中。例如，由于引用不可能全为零，`Option<&T>` 可以使用全零来表示 `None`，从而避免花费额外的一个字节（加上填充）来存储判别字节。编译器可以用同样的方式优化布尔值，甚至可能更进一步。考虑类型 `Option<Option<bool>>>`。由于编译器知道布尔值要么是 `0x00`，要么是 `0x01`，所以可以自由地使用 `0x02` 来表示 `Some(None)`，使用 `0x03` 来表示 `None`。非常简洁明了！但是，如果有人将字节 0x03 视为布尔值，然后将该值放入以这种方式优化的 `Option<Option<bool>>` 中，就会发生糟糕的事情。

&nbsp;&nbsp;&nbsp;&nbsp;值得重申的是，Rust 编译器当前是否实现了这项优化并不重要。关键在于，Rust 编译器允许这样做，因此，你编写的任何不安全代码都必须遵循该约定，否则，如果行为发生变化，以后可能会出现 bug。

### 持有的指针类型

指向自身内存的类型（例如 `Box` 和 `Vec`）通常会受到与持有指向内存的独占引用相同的优化，除非它们通过共享引用显式访问。具体来说，编译器会假设指向的内存在其他地方没有共享或别名，并基于该假设进行优化。例如，如果您从 `Box` 中提取指针，然后从同一个指针构造两个 `Box`，并将它们包装在 `ManuallyDrop` 中以防止重复释放，则很可能会进入未定义行为区域。即使您只通过共享引用访问内部类型，情况也是如此。（我说“可能”是因为语言参考中尚未完全确定这一点，但已经达成了大致的共识。）

### 存储无效值

有时你需要存储一个当前对其类型无效的值。最常见的例子是，你想为某个类型 T 分配一块内存，然后从网络等设备读取字节。在所有字节都读入之前，该内存不会是一个有效的 T。即使你只是尝试将字节读入一个 u8 切片，也必须先将这些 u8 清零，因为从未初始化的内存构造 u8 也是未定义的行为。

&nbsp;&nbsp;&nbsp;&nbsp;`MaybeUninit<T>` 类型是 Rust 处理无效值的机制。`MaybeUninit<T>` 存储的是一个 `T`（它是 `#[repr(transparent)]`），但编译器知道不对 `T` 的有效性做任何假设。它不会假设引用非空，`Box<T>` 不是悬空，或者 `bool` 是 0 或 1。这意味着在 `MaybeUninit` 中保存一个由未初始化内存支持的 `T` 是安全的（顾名思义）。`MaybeUninit` 在其他需要临时存储可能无效值的不安全代码中也是一个非常有用的工具。例如，您可能需要存储一个带别名的 `Box<T>`，或者暂时存储一个 `char` 代理——`MaybeUninit` 就是您的好帮手。

&nbsp;&nbsp;&nbsp;&nbsp;使用 `MaybeUninit` 通常只需做三件事：使用 `MaybeUninit::uninit` 方法创建它；使用 `MaybeUninit::as _mut_ptr` 写入其内容；或者在内部 `T` 再次有效后，使用 `MaybeUninit::assume_init` 获取它。顾名思义，uninit 会创建一个新的 `MaybeUninit<T>`，其大小与初始保存未初始化内存的 T 相同。`as_mut_ptr` 方法会返回一个指向内部 `T` 的原始指针，您可以向其写入数据；您可以读取它，但读取任何未初始化的位都是未定义的行为。最后，不安全的 `assume_init` 方法会使用 `MaybeUninit<T>`，并在断言后备内存现在构成一个有效 `T` 之后，将其内容作为 `T` 返回。

&nbsp;&nbsp;&nbsp;&nbsp;使用 `MaybeUninit` 通常只需做三件事：使用 `MaybeUninit::uninit` 方法创建它；使用 `MaybeUninit::as _mut_ptr` 写入其内容；或者在内部 `T` 再次有效后，使用 `MaybeUninit::assume_init` 获取它。顾名思义，`uninit` 会创建一个新的 `MaybeUninit<T>`，其大小与初始保存未初始化内存的 `T` 相同。`as_mut_ptr` 方法会返回一个指向内部 `T` 的原始指针，您可以向其写入数据；您可以读取它，但读取任何未初始化的位都是未定义的行为。最后，不安全的 `assume_init` 方法会使用 `MaybeUninit<T>`，并在断言后备内存现在构成一个有效 `T` 之后，将其内容作为 `T` 返回。

&nbsp;&nbsp;&nbsp;&nbsp;清单 9-5 展示了如何使用 `MaybeUninit` 安全地初始化字节数组而无需显式将其清零的示例。

```rust
fn fill(gen: impl FnMut() -> Option<u8>) {
 let mut buf = [MaybeUninit::<u8>::uninit(); 4096];
 let mut last = 0;
 for (i, g) in std::iter::from_fn(gen).take(4096).enumerate() {
 buf[i] = MaybeUninit::new(g);
 last = i + 1;
 }
 // Safety: all the u8s up to last are initialized.
let init: &[u8] = unsafe {
 MaybeUninit::slice_assume_init_ref(&buf[..last])
};
 // ... do something with init ...
}

// 示例 9-5：使用 MaybeUninit 安全地初始化数组
```

&nbsp;&nbsp;&nbsp;&nbsp;虽然我们可以将 `buf` 声明为 `[0; 4096]`，但这会要求函数在执行之前先将所有*零*写入堆栈，即使它很快就会再次覆盖它们。通常情况下，这不会对性能造成明显的影响，但如果这是一个足够热的循环，可能会！在这里，我们改为允许数组保留函数调用时堆栈上的任何值，然后只覆盖我们最终需要的值。

> 丢弃部分初始化的内存时要小心。如果在 `MaybeUninit<T>` 完全初始化之前，`panic`导致意外的提前丢弃，则必须注意只丢弃 `T` 中现在有效的部分（如果有）。你可以直接丢弃 `MaybeUninit`，然后忽略其后备内存，但如果它包含一个 `Box`，则最终可能会导致内存泄漏！

## Panics

确保使用不安全操作的代码安全的一个重要且经常被忽视的方面是，代码还必须准备好处理`panic`。具体来说，正如我们在第 5 章中简要讨论的那样，Rust 在大多数平台上的默认`panic`处理程序不会因`panic`而导致程序崩溃，而是会展开当前线程。展开`panic`实际上会丢弃当前作用域中的所有内容，从当前函数返回，丢弃包含该函数的作用域中的所有内容，依此类推，一直到堆栈向下，直到到达当前线程的第一个堆栈帧。如果你在不安全代码中没有考虑展开`panic`，你可能会遇到麻烦。例如，考虑示例 9-6 中的代码，它试图高效地将多个值一次性推送到 `Vec` 中。

```rust
pl<T: Default> Vec<T> {
 pub fn fill_default(&mut self) {
 let fill = self.capacity() - self.len();
 if fill == 0 { return; }
 let start = self.len();
 unsafe {
 self.set_len(start + n);
Unsafe Code   159
 for i in 0..fill {
 *self.get_unchecked_mut(start + i) = T::default();
 }
 }
 }
}

// 示例 9-6：一种看似安全的使用默认值填充 Vector 的方法
```

&nbsp;&nbsp;&nbsp;&nbsp;想象一下，如果调用 `T::default` 时发生恐慌，这段代码会发生什么。首先，`fill_default` 会丢弃其所有本地值（这些值只是整数），然后返回。调用者也会执行同样的操作。在堆栈的某个位置，我们到达了 `Vec` 的所有者。当所有者丢弃该向量时，我们遇到了一个问题：向量的长度现在表明我们拥有的 `T` 的数量超过了由于调用 `set_len` 而实际生成的 `T` 的数量。例如，如果第一次调用 `T::default` 时我们打算填充 8 个元素，就发生了`panic`，这意味着 `Vec::drop` 会在 8 个实际上包含未初始化内存的 `T` 上调用 drop！

&nbsp;&nbsp;&nbsp;&nbsp;这种情况下的修复方法很简单：代码必须在写入所有元素后更新长度。如果我们没有仔细考虑解除`panic`对不安全代码正确性的影响，我们就不会意识到这个问题。

&nbsp;&nbsp;&nbsp;&nbsp;当你梳理代码以查找此类问题时，你需要留意任何可能引发`panic`的语句，并考虑如果它们引发`panic`，你的代码是否安全。或者，检查你是否能够确信，相关代码永远不会引发恐慌。尤其要注意任何调用用户代码的代码——在这种情况下，你无法控制恐慌，应该假设用户代码会引发`panic`。

&nbsp;&nbsp;&nbsp;&nbsp;当您使用 `?` 运算符从函数提前返回时，也会出现类似的情况。如果您这样做，请确保即使函数未执行剩余代码，代码仍然是安全的。由于您明确选择了 `?` 运算符，因此很少会让您措手不及，但仍然值得留意。

## 转换

正如我们在第二章中讨论的那样，两个同为 `#[repr(Rust)]` 的类型，即使它们具有相同类型和顺序的字段，在内存中的表示也可能不同。这反过来意味着，在两个不同类型之间进行强制类型转换是否安全并不总是显而易见的。事实上，Rust 甚至不能保证同一个类型的两个实例，如果其泛型参数本身的布局方式相同，那么它们的表示方式也相同。例如，在示例 9-7 中，A 和 B 不能保证具有相同的内存表示。

```rust
struct Foo<T> {
 one: bool,
 two: PhantomData<T>,
}
struct Bar;
struct Baz;

type A = Foo<Bar>;
type B = Foo<Baz>;

// 清单 9-7：类型布局不可预测。
```
&nbsp;&nbsp;&nbsp;&nbsp;在不安全代码中进行类型转换时，务必牢记 `repr(Rust)` 缺乏保证——仅仅因为两种类型感觉应该可以互换，其实并非如此。在两种具有不同表示形式的类型之间进行转换，很容易导致未定义行为。在撰写本文时，Rust 社区正在积极制定类型表示的具体规则，但目前，几乎没有给出保证，所以我们只能接受这种情况。

&nbsp;&nbsp;&nbsp;&nbsp;即使保证相同的类型在内存中具有相同的表示形式，在类型嵌套时仍然会遇到同样的问题。例如，虽然 `UnsafeCell<T>`、`MaybeUninit<T>` 和 `T` 实际上都只保存一个 `T`，你可以随心所欲地在它们之间进行强制类型转换，但一旦你有了 `Option<MaybeUninit<T>>` 这样的类型，这种转换就变得毫无意义了。虽然 `Option<T>` 可以利用利基优化（使用 `T` 的某个无效值来表示 `Option` 的 `None` 值），但 `MaybeUninit<T>` 可以保存任何位模式，因此这种优化不适用，并且必须为 `Option` 鉴别符保留一个额外的字节。

&nbsp;&nbsp;&nbsp;&nbsp;一旦使用包装器类型，不仅仅是优化会导致布局出现差异。例如，以示例 9-8 中的代码为例；这里，尽管提供的类型均为空，但 `Wrapper<PhantomData<u8>>` 和 `Wrapper<PhantomData<i8>>` 的布局却完全不同！

```rust
struct Wrapper<T: SneakyTrait> {
 item: T::Sneaky,
 iter: PhantomData<T>,
}
trait SneakyTrait {
 type Sneaky;
}
impl SneakyTrait for PhantomData<u8> {
 type Sneaky = ();
}
impl SneakyTrait for PhantomData<i8> {
 type Sneaky = [u8; 1024];
}

// 清单 9-8：包装类型使得转换难以正确进行。
```

&nbsp;&nbsp;&nbsp;&nbsp;所有这些并不是说你永远不能在 Rust 中转换类型。事情会变得容易得多，例如，当你控制所有涉及的类型及其特征实现，或者类型是 `#[repr(C)]` 时。你只需要知道，Rust 对内存表示的保证很少，并相应地编写代码！

## 丢弃检查

Rust 借用检查器本质上是一个复杂的工具，用于在编译时确保代码的健全性，这反过来又赋予了 Rust 一种表达代码“安全”的方式。借用检查器的具体工作原理超出了本书的讨论范围，但有一种检查，即丢弃检查，值得详细探讨，因为它与不安全代码有一些直接的关系。为了理解丢弃检查，让我们站在 Rust 编译器的角度，看一下两个代码片段。首先，看一下示例 9-9 中的短短三行代码，它接受一个变量的可变引用，然后立即改变该变量。

```rust
let mut x = true;
let foo = Foo(&mut x);
x = false;

// 示例 9-9：Foo 的实现决定了这段代码是否应该编译
```

&nbsp;&nbsp;&nbsp;&nbsp;在不知道 `Foo` 定义的情况下，你能判断这段代码是否应该编译吗？当我们设置 `x = false` 时，仍然有一个 `foo` 函数挂起，它会在作用域末尾被丢弃。我们知道 `foo` 包含 `x` 的可变借用，这表明修改 `x` 所需的可变借用是非法的。但允许它这样做有什么坏处呢？事实证明，只有当 `Foo` 实现了 `Drop` 接口时，允许 `x` 的修改才会有问题——如果 `Foo` 没有实现 `Drop` 接口，那么我们知道 `Foo` 在最后一次使用 `x` 之后不会再触碰它的引用。由于最后一次使用是在我们需要赋值操作的独占引用之前，所以我们可以允许这段代码！另一方面，如果 `Foo` 实现了 `Drop` 接口，我们就不能允许这段代码，因为 `Drop` 接口的实现可能会使用 `x` 的引用。

&nbsp;&nbsp;&nbsp;&nbsp;热身完毕，请看一下示例 9-10。在这个不那么直接的代码片段中，可变引用被隐藏得更深。

```rust
fn barify<’a>(_: &’a mut i32) -> Bar<Foo<’a>> { .. }
let mut x = true;
let foo = barify(&mut x);
x = false;

// 示例 9-10：Foo 和 Bar 的实现决定了这段代码是否应该编译
```

&nbsp;&nbsp;&nbsp;&nbsp;同样，在不知道 `Foo` 和 `Bar` 的定义的情况下，你能判断这段代码是否应该编译吗？让我们考虑一下如果 `Foo` 实现了 `Drop` 而 `Bar` 没有实现会发生什么，因为这是最有趣的情况。通常，当 `Bar` 超出范围或被丢弃时，它仍然必须丢弃 `Foo`，这意味着代码应该被拒绝，原因与之前相同：`Foo::drop` 可能会访问对 `x` 的引用。然而，`Bar` 可能根本不直接包含 `Foo`，而只是 `PhantomData<Foo<'a>>`或 `&'static Foo<'a>`，在这种情况下，代码实际上是可以接受的——即使 `Bar` 被丢弃，`Foo::drop` 从未被调用，并且对 `x` 的引用从未被访问。我们希望编译器接受这种类型的代码，因为即使编译器很难检测到这种情况，人类也能够识别出它是可以接受的。

&nbsp;&nbsp;&nbsp;&nbsp;我们刚刚讲解的逻辑是丢弃检查。通常情况下，它不会对不安全代码造成太大影响，因为它的默认行为符合用户预期，但有一个主要例外：悬垂泛型参数。假设你正在实现自己的 `Box<T>` 类型，有人像示例 9-9 中那样将一个 `&mut x` 放入其中。你的 `Box` 类型需要实现 `Drop` 来释放内存，但除了丢弃 `T` 之外，它不会访问 `T`。由于丢弃 `&mut` 不会执行任何操作，因此在`Box`最后一次被访问之后、被丢弃之前，代码再次访问 `&mut x` 应该完全没问题！为了支持这样的类型，Rust 提供了一个名为 `dropck_eyepatch` 的不稳定`trait`（因为它使丢弃检查部分盲化）。该`trait`很可能永远处于不稳定状态，并且仅旨在作为一种临时的应急方案，直到设计出合适的机制。 `dropck_eyepatch` 功能添加了一个 `#[may_dangle]` 属性，您可以将其作为前缀添加到类型的 `Drop` 实现中，作为通用生命周期和类型的前缀，以告知丢弃检查机制，除了丢弃之外，您不会再使用带注解的生命周期或类型。您可以这样使用它：

```rust
unsafe impl<#[may_dangle] T> Drop for ..
```

&nbsp;&nbsp;&nbsp;&nbsp;这个逃生出口允许类型声明给定的泛型参数在 `Drop` 中不被使用，从而支持像 `Box<&mut T>` 这样的用例。然而，如果你的 `Box<T>` 持有一个原始堆指针 `*mut T`，并且允许 `T` 使用 `#[may_dangle]` 悬空，那么它也会引入一个新问题。具体来说， `*mut T` 会让 Rust 的 `drop` 检查认为你的 `Box<T>` 不拥有 `T`，因此它也不会调用 `T::drop`。结合 `may_dangle` 断言，我们在 `Box<T>` 被 `drop` 时不会访问 `T`，`drop` 检查现在得出结论，如果 `Box<T>` 中的 `T` 直到 `Box` 被 `drop` 才存在，那么它是可以的（就像示例 9-10 中简化的 `&mut x` 一样）。但事实并非如此，因为我们确实调用了 `T::drop`，而它本身可能会访问指向 `x` 的引用。

&nbsp;&nbsp;&nbsp;&nbsp;幸运的是，修复方法很简单：我们添加一个 `PhantomData<T>` 来告诉丢弃检查，即使 `Box<T>` 不包含任何 `T`，并且在丢弃时不会访问 `T`，它仍然拥有一个 `T`，并且在 `Box` 被丢弃时会丢弃一个 `T`。示例 9-11展示了我们假设的 `Box` 类型的样子。

```rust
struct Box<T> {
 t: NonNull<T>, // NonNull not *mut for covariance (Chapter 1)
 _owned: PhantomData<T>, // For drop check to realize we drop a T
}
unsafe impl<#[may_dangle] T> for Box<T> { /* ... */ }

// 示例 9-11：Box 的定义，在放置检查方面具有最大的灵活性
```

&nbsp;&nbsp;&nbsp;&nbsp;这种交互很微妙，很容易被忽略，但只有当你使用不稳定的 `#[may_dangle]` 属性时才会出现。希望本节能起到警示作用，这样当你以后看到不安全的 `impl Drop` 时，你就知道也要查找 `PhantomData<T>` 了！

> 对于与 `Drop` 相关的不安全代码，另一个注意事项是确保你有一个 `Type<T>`，允许 `T` 在自身被丢弃后继续存在。例如，如果你正在实现延迟垃圾回收，则还需要添加 `T: 'static`。否则，如果 `T = WriteOnDrop<&mut U>`，则后续对 `T` 的访问或丢弃可能会触发未定义的行为！

## 应对恐惧

读完本章后，你现在可能比开始之前更加害怕不安全代码了。虽然这可以理解，但需要强调的是，编写安全的不安全代码不仅是可能的，而且大多数情况下甚至并不难。关键在于确保谨慎处理不安全代码；这已经解决了一半的问题。在诉诸不安全代码之前，务必确保没有其他安全的实现方式可以替代。

&nbsp;&nbsp;&nbsp;&nbsp;在本章的剩余部分，我们将介绍一些技术和工具，它们可以帮助您在没有其他方法的情况下，对不安全代码的正确性更有信心。

### 管理不安全边界

人们很容易在局部层面上推断不安全性；也就是说，只考虑你刚刚编写的不安全代码块是否安全，而没有过多考虑它与代码库其他部分的交互。不幸的是，这种局部推理往往会给你带来麻烦。`Unpin trait` 就是一个很好的例子——你可能为你的类型编写了一些代码，使用 `Pin::new_unchecked` 来生成对该类型字段的固定引用，并且这些代码在你编写时可能是完全安全的。但是，在稍后的某个时间点，你（或其他人）可能会为该类型添加一个 `Unpin` 的安全实现，然后这段不安全的代码就突然变得不再安全了，即使它与新的实现相差甚远！

&nbsp;&nbsp;&nbsp;&nbsp;安全性是一种属性，只能在与不安全代码块相关的所有代码的隐私边界处进行检查。隐私边界在这里与其说是一个正式术语，不如说是试图描述“代码中任何可以修改不安全代码块的部分”。例如，如果你在标记为 `pub` 或 `pub(crate)` 的模块 `bar` 中声明了一个公共类型 `Foo`，那么同一 `crate` 中的任何其他代码都可以实现 `Foo` 的方法和特征。因此，如果你的不安全代码的安全性取决于 `Foo` 不实现具有特定签名的特定特征或方法，那么你需要记住在每次为 `Foo` 添加实现时重新检查该不安全代码块的安全性。另一方面，如果 `Foo` 对整个 `crate` 不可见，那么更小的作用域集就能够添加有问题的实现，因此，意外添加破坏安全不变量的实现的风险就会相应降低。如果 `Foo` 是私有的，那么只有当前模块和任何子模块可以添加这样的实现。

&nbsp;&nbsp;&nbsp;&nbsp;同样的规则也适用于访问字段：如果不安全块的安全性依赖于类型字段的某些不变量，那么任何可以接触这些字段的代码（包括安全代码）都属于不安全块的隐私边界。同样，最小化隐私边界也是最佳方法——无法访问字段的代码不会破坏你的不变量！

&nbsp;&nbsp;&nbsp;&nbsp;由于不安全代码通常需要这种广泛的推理，最佳做法是尽可能地将不安全部分封装在代码中。以单个模块的形式提供不安全部分，并努力为该模块提供一个完全安全的接口。这样，您只需审核该模块的内部结构以获取不变量。或者更好的方法是，将不安全部分放在它们自己的 `crate` 中，这样就不会意外留下任何漏洞！

&nbsp;&nbsp;&nbsp;&nbsp;然而，将复杂的不安全交互完全封装到一个安全的接口中并不总是可行的。在这种情况下，请尝试缩小公共接口中必须不安全的部分，使其数量尽可能少，并为其命名以明确传达需要注意的事项，然后进行严格的文档记录。

&nbsp;&nbsp;&nbsp;&nbsp;有时，删除内部 API 上的 `unsafe` 标记很诱人，这样就不必在整个代码中都使用 `unsafe {}` 了。毕竟，在代码中，你知道如果之前调用过 `bazzify`，就永远不要调用 `frobnify`，对吧？删除 `unsafe` 注释虽然可以让代码更简洁，但从长远来看通常是一个糟糕的决定。一年后，当你的代码库增长时，你删除了一些安全不变量，而你“只想快速地拼凑这一个功能”，很可能会无意中违反其中一个不变量。而且，由于你不必输入 `unsafe`，你甚至不会想到去检查。此外，即使你从不犯错，其他代码贡献者又会怎样呢？最终，更简洁的代码不足以成为删除故意制造噪音的 `unsafe` 标记的理由。

### 阅读和撰写文档

&nbsp;&nbsp;&nbsp;&nbsp;毋庸置疑，如果您编写了一个不安全函数，则必须记录该函数在哪些条件下可以安全调用。在这里，清晰和完整都很重要。不要遗漏任何不变量，即使您已经在其他地方编写了它们。如果您的类型或模块需要某些全局不变量（这些不变量必须始终适用于该类型的所有用途），则请提醒读者，他们也必须在每个不安全函数的文档中遵守这些全局不变量。开发人员通常会以临时、按需的方式阅读文档，因此您可以假设他们可能没有阅读您精心编写的模块级文档，并且需要提醒他们阅读。

&nbsp;&nbsp;&nbsp;&nbsp;可能不太明显的是，您还应该记录所有不安全的实现和块——将其视为提供证据，证明您确实遵守了相关操作所要求的契约。例如，`slice::get_unchecked` 要求提供的索引在切片的边界内；当您调用该方法时，请在其上方添加注释，解释您如何知道索引实际上保证在边界内。在某些情况下，不安全块所需的不变量非常多，您的注释可能会很长。这是一件好事。我曾多次尝试为不安全块编写安全注释，但中途意识到我实际上没有遵守关键的不变量，从而发现错误。一年后，当您必须修改这段代码并确保它仍然安全时，您也会感谢自己。您的项目贡献者偶然发现了这个不安全的调用并想了解发生了什么，他们也会感谢我。

&nbsp;&nbsp;&nbsp;&nbsp;在深入编写不安全代码之前，我强烈建议你从头到尾阅读 [Rustonomicon] (https://doc.rust-lang.org/nomicon/)。其中有很多细节很容易被忽略，如果你不了解它们，它们会反过来给你带来麻烦。我们在本章中已经涵盖了其中的许多细节，但多加注意总是好的。此外，如果你有疑问，也应该充分利用 Rust 参考资料。它会定期更新，即使你对某个假设是否正确有一点点不确定，参考资料也可能会指出来。如果答案是否定的，可以考虑创建一个 issue，以便它被添加！

## 检查你的工作

好的，你写了一些不安全的代码，反复检查了所有不变量，并且认为它已经准备好了。在将其投入生产之前，你应该使用一些自动化工具来运行你的测试套件（你有一个测试套件，对吧？）。

&nbsp;&nbsp;&nbsp;&nbsp;第一个是 `Miri`，即中级中间表示解释器。`Miri` 不会将您的代码编译成机器码，而是直接解释 Rust 代码。这使得 `Miri` 能够更清晰地了解您的程序正在执行的操作，从而检查您的程序是否执行了任何明显的恶意操作，例如从未初始化的内存中读取数据。`Miri` 可以捕获许多非常细微且特定于 Rust 的错误，对于编写不安全代码的人来说，`Miri` 堪称救星。

&nbsp;&nbsp;&nbsp;&nbsp;遗憾的是，由于 `Miri` 必须解释代码才能执行，因此在 `Miri` 下运行的代码通常比编译后的代码慢几个数量级。因此，`Miri` 实际上应该仅用于执行测试套件。它只能检查实际运行的代码，因此无法捕获测试套件未触及的代码路径中的问题。您应该将 `Miri` 视为测试套件的扩展，而不是替代品。

&nbsp;&nbsp;&nbsp;&nbsp;还有一些称为`sanitizers`的工具，它们会检测机器码，以检测运行时的错误行为。这些工具的开销和保真度差异很大，但其中一款广受欢迎的工具是 Google 的 `AddressSanitizer`。它可以检测大量内存错误，例如释放后使用、缓冲区溢出和内存泄漏，这些都是不正确的不安全代码的常见症状。与 `Miri` 不同，这些工具操作机器码，因此速度通常相当快——通常在同一数量级内。但与 `Miri` 一样，它们也仅限于分析实际运行的代码，因此，一个可靠的测试套件也至关重要。

&nbsp;&nbsp;&nbsp;&nbsp;有效使用这些工具的关键在于，通过持续集成流水线实现自动化，确保每次变更都能运行它们，并确保在发现错误时持续添加回归测试。随着测试套件质量的提升，这些工具能够更好地发现问题，因此，通过在修复已知错误的同时加入新的测试，您就能获得双倍积分！

&nbsp;&nbsp;&nbsp;&nbsp;最后，别忘了在不安全代码中大量使用断言。`panic`总比触发未定义行为好！如果可以，请使用断言检查所有假设——即使是像 `usize` 的大小这样的假设，如果你依赖它来确保安全，也要检查。如果你担心运行时成本，请使用 `debug_assert*` 宏和 `if cfg!(debug_assertions)|| cfg!(test)` 结构，仅在调试和测试上下文中执行它们。

> 纸牌屋？
>
> 不安全代码可能会违反 Rust 的所有安全保证，这常常被吹捧为 Rust 整个安全论证不过是一场骗局。令人担忧的是，只需一点错误的不安全代码，就能让整栋房子轰然倒塌，所有安全保障荡然无存。因此，支持这一论点的人有时会争辩说，至少应该只有不安全代码才能调用不安全代码，这样一来，不安全性就一直可见到应用程序的最高层。
> &nbsp;&nbsp;&nbsp;&nbsp;这种论点是可以理解的——Rust 代码的安全性确实依赖于它最终调用的所有传递性不安全代码的安全性。而且，如果其中一些不安全代码不正确，可能会对整个程序的安全性产生影响。然而，这种论点忽略了一点：所有成功的安全语言都提供了一种语言扩展功能，而这些扩展功能无法用（安全的）表面语言表达，通常以 C 语言或汇编语言编写的代码形式表达。正如 Rust 依赖于其不安全代码的正确性一样，这些语言的安全性也依赖于这些扩展的正确性。
> &nbsp;&nbsp;&nbsp;&nbsp;Rust 的不同之处在于它没有单独的扩展语言，而是允许使用 Rust 的某种方言（非安全 Rust）来编写扩展。这使得安全代码和非安全代码能够更紧密地集成，从而降低由于两者接口阻抗不匹配或开发人员只熟悉其中一种代码而不熟悉另一种代码而导致错误的可能性。这种更紧密的集成也使得编写用于分析非安全代码与安全代码交互正确性的工具变得更加容易，例如 `Miri` 等工具。此外，由于非安全 Rust 中任何未明确指出非安全的操作仍需接受借用检查器，因此许多安全检查在开发人员必须使用 C 语言等语言时是不存在的。


## 总结

在本章中，我们介绍了 `unsafe` 关键字所赋予的权限，以及使用这些权限时我们需要承担的责任。我们还讨论了编写 `unsafe` 代码的后果，以及你真正应该如何将 `unsafe` 视为一种向编译器保证你已手动检查过代码仍然安全的方式。下一章，我们将深入探讨 Rust 中的并发，并学习如何让你崭新的电脑上的所有核心都朝着同一个方向运行！























