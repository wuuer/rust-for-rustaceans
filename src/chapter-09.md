# 第九章 不安全代码

仅仅提及“不安全代码”就常常会引起 Rust 社区以及许多旁观者的强烈反应。有些人认为这“没什么大不了的”，而另一些人则谴责这是“Rust 所有承诺都是谎言的原因”。在本章中，我希望稍微揭开神秘的面纱，解释什么是不安全代码，什么不安全，
以及如何安全地使用它。在撰写本文时，很可能在您阅读本文时，Rust 对不安全代码的具体要求仍在确定中，即使它们全部确定下来，完整的描述也超出了本书的范围。相反，我会尽力为您提供所需的构建块、直觉和工具，
帮助您在大多数不安全代码中游刃有余。

&nbsp;&nbsp;&nbsp;&nbsp;你从本章中应该学到的主要内容是：不安全代码是 Rust 为开发者提供的机制，让他们能够利用编译器无法检查的不变量。我们将探讨不安全代码是如何做到这一点的，这些不变量可能是什么，以及我们可以用它做什么。

> 不变量
>
> 在本章中，我将大量讨论不变量。不变量只是“程序正确性必须为真”的一种说法。例如，在 Rust 中，一个不变量是使用 `&` 和 `&mut` 的引用不会悬垂——它们始终指向有效值。你还可以使用特定于应用程序或库的不变量，例如“头指针始终位于尾指针之前”或“容量始终是 2 的幂”。最终，不变量代表了代码正确性所需的所有假设。然而，你可能并不总是了解代码中使用的所有不变量，而这正是 bug 潜伏的地方。

&nbsp;&nbsp;&nbsp;&nbsp;至关重要的是，不安全代码并非规避 Rust 各种规则（例如借用检查）的一种方式，而是一种使用编译器之外的推理来强制执行这些规则的方法。当你编写不安全代码时，你有责任确保生成的代码是安全的。某种程度上，当 `unsafe` 作为一个关键字用于通过 `unsafe {}` 允许不安全操作时，它会产生误导；这并不是说包含的代码是不安全的，而是因为在特定上下文中，这些操作是安全的，所以允许代码执行原本不安全的操作。

&nbsp;&nbsp;&nbsp;&nbsp;本章的其余部分分为四个部分。我们将首先简要介绍关键字本身的用法，然后探讨 `unsafe` 可以做什么。接下来，我们将讨论编写安全的 `unsafe` 代码必须遵循的规则。最后，我将提供一些关于如何安全地编写 `unsafe` 代码的建议。

## unsafe 关键词

在讨论 `unsafe` 赋予你的权力之前，我们需要先了解一下它的两种不同含义。`unsafe` 关键字在 Rust 中具有双重用途：它将特定函数标记为不安全调用，并允许你在特定代码块中调用不安全的功能。例如，示例 9-1 中的方法被标记为不安全，即使它不包含任何不安全代码。在这里，`unsafe` 关键字向调用者发出警告，指出调用 `decr` 的代码必须手动检查额外的保证。

```rust
impl<T> SomeType<T> {
 pub unsafe fn decr(&self) {
 self.some_usize -= 1;
 }
}

// 示例 9-1：仅包含安全代码的不安全方法
```

&nbsp;&nbsp;&nbsp;&nbsp;清单 9-2 演示了第二种用法。这里，方法本身没有被标记为不安全，即使它包含不安全的代码。

```rust
impl<T> SomeType<T> {
 pub fn as_ref(&self) -> &T {
 unsafe { &*self.ptr }
 }
}

// 示例 9-2：包含不安全代码的安全方法
```

&nbsp;&nbsp;&nbsp;&nbsp;这两个清单在 `unsafe` 的使用上有所不同，因为它们体现了不同的契约。`decr` 要求调用者在调用该方法时要小心谨慎，而 `as_ref` 则假定调用者在调用其他 unsafe 方法（如 `decr`）时非常谨慎。为了理解原因，假设 `SomeType` 实际上是像 `Rc` 这样的引用计数类型。即使 `decr` 只减少一个数字，但该减少操作也可能通过安全方法 `as_ref` 触发未定义的行为。如果调用 `decr`，然后删除给定 `T` 的倒数第二个 `Rc`，则引用计数将降至零，并且该 `T` 将被删除——但程序可能仍会在最后一个 `Rc` 上调用 `as_ref`，最终得到一个悬垂引用。

> 未定义行为描述的是程序在运行时违反语言不变量的后果。一般来说，如果程序触发了未定义行为，其结果将完全无法预测。我们将在本章后面更详细地讨论未定义行为。

&nbsp;&nbsp;&nbsp;&nbsp;相反，只要无法使用安全代码破坏 `Rc` 的引用计数，那么像 `as_ref` 的代码那样，在 `Rc` 内部解引用指针始终是安全的——`&self` 的存在证明该指针仍然有效。我们可以利用这一点，为调用者提供一个安全的 API，以应对原本不安全的操作，这是负责任地使用 `unsafe` 的核心原则。

&nbsp;&nbsp;&nbsp;&nbsp;由于历史原因，Rust 中每个不安全 `fn` 都包含一个隐式的不安全块。也就是说，如果你声明了一个不安全 `fn`，你始终可以在该 `fn` 中调用任何不安全方法或原始操作。然而，这一决定现在被认为是一个错误，并且正在通过已被接受和实施的 RFC 2585 进行撤销。该 RFC 警告说，如果一个不安全 fn 在没有显式不安全块的情况下执行不安全操作，那么 lint 也可能会在未来的 Rust 版本中变成硬错误。这样做的目的是为了减少“盲区半径”——如果每个不安全 `fn` 都是一个巨大的不安全块，那么你可能会在不知不觉中意外执行不安全操作！例如，在示例 9-1 中的 decr 中，在当前规则下，你也可以添加 `*std::ptr::null()` 而不使用任何不安全注解。

&nbsp;&nbsp;&nbsp;&nbsp;区分 `unsafe` 作为标记和 `unsafe` 块作为启用 `unsafe` 操作的机制非常重要，因为你必须以不同的方式思考它们。`unsafe fn` 会向调用者表明，他们在调用相关 `fn` 时必须小心谨慎，并且必须确保函数记录的安全不变量成立。

&nbsp;&nbsp;&nbsp;&nbsp;同时，不安全块意味着编写该块的人仔细检查了其中执行的任何不安全操作的安全不变量是否成立。如果想要一个近似的现实世界类比，`unsafe fn` 是一个未签名的契约，要求调用代码的作者“庄严宣誓 X、Y 和 Z”。同时，`unsafe {}` 是调用代码的作者签署了块中包含的所有不安全契约。在我们学习本章的其余部分时，请记住这一点。

## 强大的权力

那么，一旦你用 `unsafe {}` 签署了不安全契约，你还能做什么呢？说实话，能做的不多。或者说，它并没有启用那么多新功能。在不安全代码块中，你可以解引用原始指针并调用`unsafe fns`。

&nbsp;&nbsp;&nbsp;&nbsp;就是这样。从技术上讲，你还可以做其他一些事情，比如访问可变变量和外部静态变量，以及访问联合体的字段，但这些对讨论的影响不大。说实话，这就足够了。这些能力加在一起，可以让你制造各种混乱，比如用 `mem::transmute` 将类型转换为另一种类型，解引用指向未知位置的原始指针，将 `&'a` 强制转换为 `&'static`，或者让类型即使它们不是线程安全的，也能跨线程共享。

&nbsp;&nbsp;&nbsp;&nbsp;在本节中，我们不会过多担心这些能力可能带来的问题。我们会把这个问题留到后面那个无聊、负责任、成熟的部分。相反，我们会看看这些闪亮的新玩具，以及它们能做什么。

### 处理原始指针

使用 `unsafe` 的一个最根本原因是为了处理 Rust 的原始指针类型：`*const T` 和 `*mut T`。你可以将它们视为与 `&T` 和 `&mut T` 类似，只是它们没有生命周期，并且不受与 `&` 类型相同的有效性规则约束（我们将在本章后面讨论）。这些类型可以互换地称为指针和原始指针，主要是因为许多开发人员本能地将引用称为指针，而称它们为原始指针可以使区别更加清晰。

&nbsp;&nbsp;&nbsp;&nbsp;由于 `*` 适用的规则比 `&` 少，因此即使在 `unsafe` 块之外，你也可以将引用强制转换为指针。只有当你想反过来，从 `*` 转换为 `&` 时，才需要 `unsafe` 操作符。通常，你会将指针转换回引用，以便对指向的数据执行一些有用的操作，例如读取或修改其值。因此，指针上常用的操作是 `unsafe { &*ptr }` （或 `&mut *`）。这里的 `*` 可能看起来很奇怪，因为代码只是构造了一个引用，而不是解引用指针，但如果你看一下类型，就会明白其中的道理；如果你有一个 `*mut T` 并且想要一个 `&mut T`，那么 `&mut ptr`只会返回一个 `&mut *mut T`。你需要 `*` 来表明你想要的是 `ptr` 指针指向的可变引用。

> 指针类型
>
> 您可能想知道 `*mut T`、`*const T` 和 `std::ptr::NonNull<T>` 之间有什么区别。确切的规范仍在制定中，但 `*mut T` 和 `*const T`/`NonNull<T>` 之间主要的实际区别在于 `*mut T` 在 `T` 中是不变的（参见第一章的“生命周期变异”），而其他两个是协变的。顾名思义，`*const T` 和`NonNull<T>` 的主要区别在于 `NonNull<T>` 不允许为空指针，而 `*const T` 可以。
> 我在这些类型中进行选择的最佳建议是，如果你能够指定相关的生命周期，凭直觉判断你会写成 `&mut` 还是 `&`。如果你会写 `&`，并且你知道指针永远不会为空，那么请使用 `NonNull<T>`。它得益于一种名为“利基优化”的出色优化：基本上，由于编译器知道该类型永远不会为空，因此它可以使用该信息来表示像 `Option<NonNull<T>>` 这样的类型，而无需任何额外开销，因为 `None` 的情况可以通过将 `NonNull` 设置为空指针来表示！空指针值在 `NonNull<T>` 类型中是一个利基。如果指针可能为空，请使用 `*const T`。如果你会写 `&mut T`，请使用 `*mut T`。

### 无法表示的生命周期

由于原始指针没有生命周期，因此它们可以用于指向值的活跃度无法在 Rust 的生命周期系统中静态表达的情况，例如，像我们在第 8 章讨论过的生成器那样的自引用结构体中的自指针。指向 `self` 的指针在 `self` 存在期间有效（并且不会移动，这就是 `Pin` 的作用），但这不是通常可以命名的生命周期。虽然整个自引用类型可能是“静态的”，但自指针不是——如果它是静态的，那么即使你把这个指针给了别人，他们也可以永远使用它，即使在 `self` 消失之后！以示例 9-3 中的类型为例；这里我们尝试将构成值的原始字节与其存储的表示一起存储。

```rust
struct Person<'a> {
 name: &'a str,
 age: usize,
}
struct Parsed {
 bytes: [u8; 1024],
 parsed: Person<'???>,
}

// 示例 9-3：尝试命名自引用的生命周期，但失败了
```

&nbsp;&nbsp;&nbsp;&nbsp;`Person` 内部的引用想要引用 `Parsed` 中以字节形式存储的数据，但 `Parsed` 中没有可以分配给该引用的生命周期。它不是 '`static`' 或类似 '`self`'（后者不存在）的类型，因为如果`Parsed` 被移动，该引用就不再有效。

&nbsp;&nbsp;&nbsp;&nbsp;由于指针没有生命周期，它们规避了这个问题，因为你不必能够命名生命周期。相反，你只需确保当你使用指针时，它仍然有效，这就是你在写 `unsafe { &*ptr }` 时所承诺的。在示例 9-3 的例子中，Person 会存储一个 `*const str`，然后在适当的时候，在能够保证指针仍然有效的情况下，将其不安全地转换为 `&str`。

&nbsp;&nbsp;&nbsp;&nbsp;类似的问题也出现在像 `Arc` 这样的类型上，它有一个指向值的指针，该值在一段时间内共享，但这段时间只有在运行时，最后一个 `Arc` 被释放时才可知。这个指针有点像“静态”，但实际上并非如此——就像在自引用的情况下，当最后一个 `Arc` 引用消失时，指针就不再有效，所以它的生命周期更像是“自身”。在 `Arc` 的“表亲”`Weak` 中，它的生命周期也是“当最后一个 `Arc` 消失时”，但由于 `Weak` 不是 `Arc`，所以它的生命周期甚至与自身无关。因此，`Arc` 和 `Weak` 都在内部使用原始指针。

### 指针运算

使用原始指针，你可以像在 C 语言中一样进行任意指针运算，通过使用 `.offset()`、`.add()` 和 `.sub()` 将指针移动到同一分配空间内的任意字节。这最常用于高度空间优化的数据结构，例如哈希表，在这些结构中，为每个元素存储一个额外的指针会增加过多的开销，并且无法使用切片。这些都是相当小众的用例，本书不会详细讨论，但如果你想了解更多信息，我鼓励你阅读 hashbrown::RawTable 的代码 (https://github.com/rust-lang/hashbrown/)！

&nbsp;&nbsp;&nbsp;&nbsp;即使你不想在调用指针后将其转换为引用，调用指针运算方法也是不安全的。造成这种情况的原因有很多，但最主要的是，将指针指向其原始指向的分配空间末尾之外是非法的。这样做会触发未定义的行为，编译器可以决定吞噬你的代码，并将其替换为只有编译器才能理解的任意代码。如果你确实使用这些方法，请仔细阅读文档！

#### 转换到指针然后再转换回来

通常，当你需要使用指针时，是因为你有一些普通的 Rust 类型，例如引用、切片或字符串，而你必须暂时过渡到指针的世界，然后再返回到原始的普通类型。因此，一些关键的标准库类型提供了将它们转换为原始组成部分（例如切片的指针和长度）的方法，以及使用这些部分将它们转换回完整部分的方法。例如，你可以使用 `as_ptr` 获取切片的数据指针，使用 `[]::len` 获取其长度。然后，你可以通过将这些相同的值提供给 `std::slice::from_raw_parts` 来重建切片。`Vec`、`Arc` 和 `String` 具有类似的方法，它们返回指向底层分配的原始指针，而 `Box` 具有 `Box::into_raw` 和`Box::from_raw`，它们执行相同的操作。

#### 玩转类型

有时，你有一个类型 `T`，并希望将其视为另一个类型 `U`。无论这是因为你需要进行闪电般的零拷贝解析，还是因为你需要调整一些生命周期，Rust 都为你提供了一些（非常不安全的）工具来实现。

&nbsp;&nbsp;&nbsp;&nbsp;其中第一个也是迄今为止最广泛使用的就是指针强制转换：你可以将一个 `*const T` 强制转换为任何其他 `*const U`（`mut` 也是如此），甚至不需要 `unsafe` 即可执行此操作。只有当你稍后尝试将强制转换后的指针用作引用时，这种不安全性才会发挥作用，因为你必须断言原始指针实际上可以用作其指向类型的引用。

&nbsp;&nbsp;&nbsp;&nbsp;这种指针类型转换在使用外部函数接口 (`FFI`) 时尤其方便——你可以将任何 Rust 指针转换为 `*const std::ffi::c_void` 或 `*mut std::ffi::c_void`，然后将其传递给需要 `void` 指针的 C 函数。同样，如果你从 C 语言中获取了一个 `void` 指针，并且之前传入了它，你可以轻松地将其转换回其原始类型。

&nbsp;&nbsp;&nbsp;&nbsp;当你想将字节序列解释为普通数据类型（例如整数、布尔值、字符和数组，或这些类型的 `#[repr(C)]` 结构体）时，指针强制转换也很有用，或者直接将这些类型写成字节流而不进行序列化。如果你想尝试这样做，需要记住许多安全不变量，但我们稍后再讨论。

### 调用不安全函数

可以说，`unsafe` 最常用的功能是它允许你调用不安全的函数。在堆栈的深层，大多数此类函数是不安全的，因为它们在某些基本层面上操作的是原始指针；但在堆栈的更高层，你往往主要通过函数调用来与不安全函数交互。

&nbsp;&nbsp;&nbsp;&nbsp;调用不安全函数所能实现的功能实际上没有限制，因为这完全取决于你与之交互的库。但总的来说，不安全函数可以分为三类：与非 Rust 接口交互的函数、跳过安全检查的函数，以及具有自定义不变量的函数。

#### 外部函数接口

Rust 允许你使用 `extern` 块（我们将在第 11 章详细讨论）声明在 Rust 以外的语言中定义的函数和静态变量。声明这样的块，实际上是在告诉 Rust，其中出现的项将在最终程序二进制文件链接时由某个外部源（例如，你正在集成的 C 库）实现。由于 `extern` 块不受 Rust 控制，因此访问它们本质上是不安全的。如果你在 Rust 中调用一个 C 函数，那么一切都将不保——它可能会覆盖你的整个内存内容，并将你所有整齐排列的引用破坏成指向内核某个位置的随机指针。同样，`extern` 静态变量可能随时被外部代码修改，并且可能被填充各种与其声明类型完全不符的错误字节。不过，在不安全的块中，你可以随心所欲地访问外部变量，只要你愿意保证外部变量的另一方遵守 Rust 的规则。

#### 我会通过安全检查

通过引入额外的运行时检查，一些不安全的操作可以变得完全安全。例如，访问切片中的项是不安全的，因为您可能会尝试访问超出切片长度的项。但是，考虑到这种操作的常见性，如果对切片进行索引操作不安全，那就太可惜了。因此，安全的实现包含边界检查，如果提供的索引超出范围，则（取决于您使用的方法）会引发 `panic` 或返回 `Option`。这样，即使您传入的索引超出了切片的长度，也不会导致未定义的行为。另一个例子是哈希表，它会对您提供的键进行哈希处理，而不是让您自己提供哈希值；这确保您永远不会尝试使用错误的哈希值访问键。

&nbsp;&nbsp;&nbsp;&nbsp;然而，在对极致性能的无休止追求中，一些开发者可能会发现这些安全检查在他们最紧凑的循环中增加了过多的开销。为了满足峰值性能至关重要且调用者知道索引在边界内的情况，许多数据结构提供了不包含这些安全检查的特定方法的替代版本。这些方法的名称中通常会包含 `unchecked` 一词，以表明它们盲目地信任所提供的参数是安全的，并且不会执行任何令人讨厌且缓慢的安全检查。例如，`NonNull::new_unchecked`、`slice::get_unchecked`、`NonZero::new_unchecked`、`Arc::get_mut_unchecked` 和 `str::from_utf8_unchecked`。

&nbsp;&nbsp;&nbsp;&nbsp;实践中，未经检查的方法在安全性和性能方面的权衡很少值得。性能优化的原则是先测量，再优化。

#### 自定义不变量

大多数 `unsafe` 函数的使用都在一定程度上依赖于自定义的不变量。也就是说，它们依赖于 Rust 自身提供的不变量，这些不变量特定于特定的应用程序或库。由于许多函数都属于此类，因此很难对这类 `unsafe` 函数进行很好的概括。因此，我将提供一些您在实践中可能会遇到并希望使用的带有自定义不变量的 unsafe 函数的示例：

##### MaybeUninit::assume_init

`MaybeUninit` 类型是 Rust 中少数几种可以存储其类型无效值的方式之一。你可以将 `MaybeUninit<T>` 视为一个 T，但目前可能不合法地用作 T。
例如，`MaybeUninit<NonNull>` 可以保存空指针，`MaybeUninit<Box>` 可以保存悬空堆指针，而 `MaybeUninit<bool>` 可以保存数字 3 的位模式（通常必须为 0 或 1）。如果你正在逐位构造值，或者处理最终会变为有效的零值或未初始化内存（例如通过调用 `std::io::Read::read` 进行填充），那么 `MaybeUninit` 会非常方便。`assume_init` 函数断言 `MaybeUninit` 现在保存了类型 T 的有效值，因此可以用作 `T`。

##### ManuallyDrop::drop

`ManuallyDrop` 类型是类型 `T` 的包装器类型，当 `ManuallyDrop` 被丢弃时，它不会丢弃该 `T`。或者换句话说，它将外部类型（`ManuallyDrop`）的丢弃与内部类型（`T`）的丢弃解耦。它通过 `DerefMut<Target = T>` 实现了对 `T` 的安全访问，同时还提供了一个 `drop` 方法（独立于 `Drop trait` 的 `drop` 方法），用于丢弃包装的 `T` 而不丢弃 `ManuallyDrop`。也就是说，`drop` 函数即使丢弃了 `T`，也会接受 `&mut self` ，因此会留下 `ManuallyDrop`。如果您必须显式丢弃一个无法移动的值（例如在 `Drop trait` 的实现中），这会非常方便。一旦该值被丢弃，尝试访问该 `T` 就不再安全，这就是为什么 `drop` 调用是不安全的——它断言该 `T` 永远不会被再次访问。

##### std::ptr::drop_in_place

`drop_in_place` 允许你通过指向该值的指针直接调用该值的析构函数。这种方法并不安全，因为调用后，指针指向的对象会被遗留，所以如果之后某些代码尝试取消引用该指针，就会遇到麻烦！当你需要重用内存（例如在 `arena` 分配器中），并且需要就地丢弃旧值而不回收其周围的内存时，此方法尤其有用。

##### Waker::from_raw

在第八章中，我们讨论了 `Waker` 类型，以及它是如何由一个数据指针和一个包含手动实现的虚函数表 (vtable) 的 `RawWaker` 组成的。一旦 `Waker` 被构造，虚函数表中的原始函数指针（例如 `wake` 和 `drop`）就可以从安全代码中调用（分别通过 `Waker::wake` 和 `drop(waker)`）。异步执行器在 `Waker::from_raw` 中断言其虚函数表中的所有指针都是有效的函数指针，并且遵循 `RawWakerVTable` 文档中规定的契约。

##### std::hint::unreachable_unchecked

`hint` 模块包含一些函数，它们会向编译器提供有关周围代码的提示，但实际上不会生成任何机器码。`unreachable_unchecked` 函数会特别告知编译器，程序在运行时不可能到达某段代码。这反过来又允许编译器基于这些知识进行优化，例如消除指向该位置的条件分支。与 `unreachable!` 宏不同，如果代码确实到达了该行，它就会引发`panic`，而错误的 `unreachable_unchecked` 函数的影响则难以预测。编译器优化可能会导致一些奇怪且难以调试的行为，更不用说你的程序会在它认为正确的事情实际上并非如此时继续运行！

##### std::ptr::{read,write}_{unaligned,volatile}

`ptr` 模块包含许多函数，可用于处理奇数指针——即那些不符合 Rust 通常对指针的假设的指针。第一个函数是 `read_unaligned` 和 `write_unaligned`，它们允许您访问指向 `T` 的指针，即使该 T 未按照其对齐方式存储（参见第二章关于对齐的部分）。如果 `T` 直接包含在字节数组中，或者与其他值打包在一起而没有进行适当的填充，则可能会发生这种情况。第二个值得注意的函数是`read_volatile` 和 `write_volatile`，它们允许您操作不指向普通内存的指针。具体来说，这些函数将始终访问给定的指针（例如，即使您连续两次读取同一个指针，它们也不会被缓存在寄存器中），并且编译器不会将 `volatile` 访问相对于其他 `volatile` 访问进行重新排序。当使用不受普通 DRAM 内存支持的指针时，易失性操作非常方便——我们将在第 11 章进一步讨论这一点。最终，这些方法是不安全的，因为它们会取消引用给定的指针（并且指向一个拥有的 `T`），因此作为调用者，您需要签署与此相关的所有合同。

##### std::thread::Builder::spawn_unchecked

我们熟知并喜爱的普通 `thread::spawn` 要求提供的闭包是“静态”的。这种限制源于这样一个事实：生成的线程可能运行一段不确定的时间；如果我们被允许使用对调用者堆栈的引用，调用者
可能会在生成的线程退出之前就返回，从而导致引用无效。然而，有时你知道调用者中的某些非“静态”值会比生成的线程存活得更久。如果你在丢弃相关值之前加入线程，或者在确定生成的线程将不再使用该值之后才严格丢弃该值，就可能会发生这种情况。这就是 `spawn_unchecked` 的用武之地——它没有“静态”的限制，因此允许你实现这些用例，只要你愿意签署协议，保证不会因此发生不安全的访问。不过，要小心`panic`；如果调用者崩溃，它可能会比你计划的更早地丢弃值，并导致生成的线程中出现未定义的行为！

请注意，所有这些方法（实际上，标准库中的所有不安全方法）都为其安全不变量提供了明确的文档，任何不安全方法都应如此。

## 实现不安全的trait

不安全`trait`并非使用不安全，而是实现不安全。这是因为不安全代码可以依赖于不安全`trait`实现的正确性（由`trait`文档定义）。例如，要实现不安全`trait` `Send`，您需要编写 `unsafe impl Send for ...`。与不安全函数一样，不安全特征通常具有自定义不变量，这些不变量在`trait`文档中指定（或至少应该指定）。因此，很难将不安全`trait`作为一个整体进行介绍，因此在这里，我也将给出一些来自标准库的常见示例，这些示例值得一读。

### Send and Sync

`Send` 和 `Sync` `trait` 分别表示某个类型可以安全地跨线程发送或共享。我们将在第 10 章中详细讨论这些 `trait`，但现在您需要知道的是，它们是自动 `trait`，因此编译器通常会为大多数类型实现它们。但是，与自动 `trait` 的情况一样，如果相关类型的任何成员本身不是 `Send` 或 `Sync` `trait`，则不会实现 `Send` 和 `Sync` `trait`。

&nbsp;&nbsp;&nbsp;&nbsp;在不安全代码的上下文中，这个问题主要源于原始指针，它既不是 `Send` 也不是 `Sync`。乍一看，这似乎很合理：编译器无法知道还有谁可能拥有指向相同值的原始指针，也不知道他们此刻可能如何使用它，那么，这种类型如何才能安全地跨线程发送呢？不过，既然我们都是经验丰富的不安全开发人员，这个论点似乎站不住脚——毕竟，解引用原始指针本身就已经不安全了，那么处理 `Send` 和 `Sync` 的不变量又有什么不同呢？

&nbsp;&nbsp;&nbsp;&nbsp;严格来说，原始指针可以同时支持 `Send` 和 `Sync` 操作。问题在于，如果是这样，包含原始指针的类型本身将自动支持 `Send` 和 `Sync` 操作，即使它们的作者可能没有意识到这一点。这样一来，开发人员可能会不安全地取消引用原始指针，而从未考虑过如果这些类型跨线程发送或共享会发生什么，从而无意中引入未定义的行为。因此，原始指针类型会阻止这些自动实现，作为对不安全代码的额外保护，以确保作者明确签署协议，声明他们也遵循了 `Send` 和 `Sync` 的不变量。

> `Send` 和 `Sync` 的不安全实现的一个常见错误是忘记为泛型参数添加边界：`unsafe impl<T: Send> Send for MyUnsafeType<T> {}`。

### GlobalAlloc

`GlobalAlloc` `trait` 是在 Rust 中实现自定义内存分配器的方法。本书不会过多讨论这个话题，但这个 `trait` 本身很有趣。示例 9-4 给出了 `GlobalAlloc` `trait` 所需的方法。

```rust
pub unsafe trait GlobalAlloc {
 pub unsafe fn alloc(&self, layout: Layout) -> *mut u8;
 pub unsafe fn dealloc(&self, ptr: *mut u8, layout: Layout);
}

// 示例 9-4：GlobalAlloc trait 及其所需方法
```

该特征的核心是，它有一个用于分配新内存块的方法 `alloc`，以及一个用于释放内存块的方法 `dealloc`。`Layout` 参数描述了类型的大小和对齐方式，正如我们在第二章中讨论过的。每个方法都是不安全的，并且带有一些调用者必须遵守的安全不变量。

`GlobalAlloc` 本身也是不安全的，因为它限制的是`trait`的实现者，而不是其方法的调用者。只有`trait`的不安全性才能确保实现者同意遵守 Rust 自身对其内存分配器所假设的不变量，例如标准库中 `Box` 的实现。如果`trait`本身并非不安全，实现者可以安全地实现 `GlobalAlloc`，但会产生未对齐的指针或大小不正确的分配，这会在原本安全的代码中触发不安全性，因为这些代码假设分配是合理的。这将违反安全代码不应触发其他安全代码中的内存不安全性的规则，从而造成各种混乱。

### 竟然不是 Unpin

`Unpin` `trait` 并非不安全，这或许会让许多 Rust 开发者感到意外。读完第八章之后，你甚至可能会感到意外。毕竟，该 `trait` 旨在确保自引用类型在建立内部指针后（即被放入 `Pin` 后）被移动时不会失效。因此，`Unpin` 可以用来安全地从 `Pin` 中移除类型，这似乎有些奇怪。

`Unpin` 并非不安全 `trait`，主要有两个原因。首先，它没有必要。为你控制的类型实现 `Unpin` 并不意味着你能够安全地固定或取消固定 `!Unpin` 类型；这仍然需要调用 `Pin::new_unchecked` 或 `Pin::get_unchecked_mut` 来实现不安全机制。其次，你已经有一种安全的方法可以取消固定你控制的任何类型：`Drop trait！`当你为某个类型实现 `Drop` 时，即使你的类型之前存储在 `Pin` 中并且是 `!Unpin` 类型的，你也会被传递 `&mut self` ，所有这些都不会带来任何不安全。这种不安全的可能性被 `Pin::new_unchecked` 的不变量所覆盖，因此，创建这种 `!Unpin` 类型的 `Pin` 时必须首先遵循这些不变量。

### 何时使trait变为Unsafe

虽然目前已知的不安全`trait`很少，但所有不安全的`trait`都遵循相同的模式。如果安全代码假设该`trait`已正确实现，而该`trait`未正确实现时却可能出现内存不安全，则该`trait`应该是不安全的。

&nbsp;&nbsp;&nbsp;&nbsp;`Send` `trait` 是一个很好的例子，需要牢记——安全代码可以轻松地创建一个线程并将值传递给该线程，但如果 `Rc` 是不安全代码`Send`，那么这一系列操作很容易导致内存不安全。想象一下，如果你克隆一个 `Rc<Box>` 并将其发送给另一个线程会发生什么：这两个线程很容易同时尝试释放 `Box`，因为它们没有正确同步对 `Rc` 引用计数的访问。

&nbsp;&nbsp;&nbsp;&nbsp;`Unpin` `trait`就是一个很好的反例。虽然有可能编写出不安全的代码，如果 `Unpin` 实现不正确，就会触发内存不安全，但没有任何完全安全的代码会因为 `Unpin` 的实现而触发内存不安全。确定一个`trait`是否安全并不总是那么容易，（事实上，`Unpin` 特质在 RFC 的大部分流程中都是不安全的），但你总是可以先将其设置为不安全，然后在意识到情况确实如此后再将其设置为安全！只需记住，这是一个向后不兼容的更改。

&nbsp;&nbsp;&nbsp;&nbsp;还要记住，仅仅因为感觉某个`trait`的错误（甚至是恶意的）实现会造成很大的破坏，并不一定是将其标记为不安全的充分理由。不安全标记首先应该用于突出显示内存不安全的情况，而不仅仅是可能触发业务逻辑错误的某些情况。例如，`Eq`、`Ord`、`Deref` 和 `Hash` 特征都是安全的，即使世界上可能有很多代码在遇到恶意实现（例如，每次调用都会返回不同随机哈希值的 `Hash` 实现）时会崩溃。这也适用于不安全代码——几乎可以肯定存在内存不安全的不安全代码，在存在这样的 `Hash` 实现的情况下——但这并不意味着 `Hash` 应该是不安全的。同样，每次解引用到不同（但有效）目标的 `Deref` 实现也是如此。这种不安全的代码依赖于实际上并不成立的 `Hash` 或 `Deref` 契约；`Hash` 从未声称它是确定性的，`Deref` 也是如此。或者更确切地说，这些实现的作者从未使用 `unsafe` 关键字来做出这种声明！

> `Eq`、`Hash` 和 `Deref` 等 `trait` 之所以安全，一个重要含义是：不安全代码只能依赖于安全代码的安全性，而不能依赖于其正确性。这不仅适用于 `trait`，也适用于所有不安全/安全代码的交互。
