# 第五章 测试

在本章中，我们将探讨扩展 Rust 测试功能的各种方法，以及您可能希望添加到测试组合中的其他测试类型。Rust 内置了许多内置测试工具，这些工具在《Rust 编程语言》中有详细介绍，主要体现在 `#[test]` 属性和 tests/ 目录下。这些工具适用于各种应用程序和规模，通常足以满足您启动项目所需的一切。然而，随着代码库的发展和测试需求的日益复杂，您可能需要做的不仅仅是在各个函数上添加 `#[test]` 标签。本章分为两部分。第一部分介绍 Rust 测试机制，例如标准测试工具和条件测试代码。第二部分介绍评估 Rust 代码正确性的其他方法，例如基准测试、linting 和模糊测试。

## 测试运行机制

要理解 Rust 提供的各种测试机制，首先必须了解 Rust 如何构建和运行测试。运行 `cargo test --lib` 时，Cargo 唯一特别之处是将 `--test` 标志传递给 `rustc`。此标志指示 rustc 生成一个运行所有单元测试的测试二进制文件，而不是仅仅编译 crate 的库或二进制文件。在后台，`--test` 有两个主要作用。首先，它启用 `cfg(test) `，以便您可以有条件地包含测试代码（稍后会详细介绍）。其次，它使编译器生成一个测试工具：一个精心生成的 `main` 函数，它会在程序运行时调用每个
`#[test]` 函数。

### 测试工具

编译器通过一系列过程宏（我们将在第 7 章更深入地讨论）和少量的魔法来生成测试工具的主函数。本质上，测试工具将每个以 `#[test]` 注释的函数转换为测试描述符——这是过程宏的部分。然后，它将每个描述符的路径暴露给生成的主函数——这是魔法的部分。描述符包含测试名称、设置的任何附加选项（例如 `#[should_panic]`）等信息。测试工具的核心是迭代 crate 中的测试，运行它们，捕获它们的结果并打印结果。因此，它还包含解析命令行参数（例如 `--test-threads=1`）、捕获测试输出、并行运行列出的测试以及收集测试结果的逻辑。

截至撰写本文时，Rust 开发者正在努力将测试工具生成的关键部分变成一个公开可用的 API，以便开发者可以构建自己的测试工具。这项工作仍处于实验阶段，但该提案与目前的模型非常契合。需要解决的部分关键问题是如何确保 `#[test]` 函数即使位于私有子模块中，也能被生成的主函数使用。

集成测试（tests/ 中的测试）遵循与单元测试相同的流程，但有一个例外：它们各自被编译为独立的 crate，这意味着它们只能访问主 crate 的公共接口，并且针对未使用 `#[cfg(test)` 编译的主 crate 运行。tests/ 中的每个文件都会生成一个测试工具。子目录中的文件不会生成测试工具。

> 如果您明确需要对子目录中的文件进行测试，您可以通过调用文件 main.rs 来选择加入。

Rust 不要求您使用默认的测试工具。您可以选择不使用默认的测试工具，并实现自己的 `main` 方法，通过在 `Cargo.toml` 中为给定的集成测试设置 `harness = false` 来代表测试运行器，如清单 6-1 所示。然后，您定义的 main 方法将被调用来运行测试。

```rust
[[test]]
name = "custom"
path = "tests/custom.rs"
harness = false

// 清单 6-1：退出标准测试工具
```
如果没有测试工具，`#[test]` 周围的所有魔法都无法实现。相反，您需要编写自己的 `main` 函数来运行您想要执行的测试代码。本质上，您编写的是一个普通的 Rust 二进制文件，只不过它恰好由 `Cargo Test` 运行。该二进制文件负责处理默认工具通常执行的所有操作（如果您希望支持它们），例如命令行标志。每个集成测试的 harness 属性都是单独设置的，
因此，您可以拥有一个使用标准工具的测试文件，以及一个不使用标准工具的测试文件。

> 默认测试工具的参数
> 
> 默认测试工具支持许多命令行参数，用于配置测试的运行方式。这些参数不会直接传递给 `Cargo test`，而是传递给 `Cargo` 在您运行 `Cargo test` 时为您编译和运行的测试二进制文件。要访问这组参数，请将 `--` 传递给 `Cargo test`，然后将参数传递给测试二进制文件。例如，要查看测试二进制文件的帮助文本，请运行 `Cargo test -- --help`。
通过这些命令行参数，您可以使用许多便捷的配置选项。`--nocapture` 标志禁用运行 Rust 测试时通常会进行的输出捕获。如果您想实时观察测试的输出，而不是在测试失败后一次性全部观察，这将非常有用。您可以使用 `--test-threads` 选项来限制同时运行的测试数量，如果您的测试挂起或出现段错误，并且您想通过顺序运行测试来找出是哪个错误，这将非常有用。还有一个 `--skip` 选项，用于跳过符合特定模式的测试；`--ignored` 选项用于运行通常会被忽略的测试（例如需要运行外部程序的测试）；以及 `--list` 选项，用于列出所有可用的测试。
请记住，这些参数都是由默认测试工具实现的，因此如果您禁用它（使用 `harness = false`），则必须在主函数中自行实现所需的参数！

无需 Harness 的集成测试主要用于基准性能测试，我们稍后会看到，但当您想要运行不符合标准“一个函数，一个测试”模型的测试时，它们也会派上用场。例如，您经常会看到无 Harness 测试与模糊测试器、模型检查器以及需要自定义全局设置的测试（例如在 WebAssembly 下或使用自定义目标时）一起使用。

### #[cfg(test)]
Rust 在构建测试代码时，会设置编译器配置标志 `test`，然后您可以使用该标志与条件编译一起使用，以便将代码编译出来，除非是专门用于测试的代码。表面上看，这似乎很奇怪：难道您不想测试即将投入生产的代码吗？您当然想，但拥有专门用于测试的代码，可以让您通过几种方式编写更好、更全面的测试。

> 模拟
> 编写测试时，您通常希望对正在测试的代码以及代码可能与之交互的任何其他类型进行严格控制。例如，如果您正在测试网络客户端，您可能不想在真实网络上运行单元测试，而是希望直接控制“网络”发出的字节数以及时间。或者，如果您正在测试数据结构，您希望测试使用能够控制每个方法在每次调用时返回内容的类型。您可能还希望收集一些指标，例如给定方法的调用频率或是否发出了给定的字节序列。这些“伪”类型和实现被称为模拟，它们是任何广泛的单元测试套件的关键特性。虽然您通常可以手动完成获得这种控制所需的工作，但最好让一个库来为您处理大部分细节。这就是自动模拟发挥作用的地方。模拟库将提供生成具有特定属性或签名的类型（包括函数）的功能，以及在测试执行期间控制和自省这些生成项的机制。
Rust 中的模拟通常通过泛型进行——只要您的程序、数据结构、框架或工具对您想要模拟的任何内容（或接受特征对象）是泛型的，您就可以使用模拟库生成符合规范的类型，这些类型将实例化这些泛型参数。然后，您可以使用生成的模拟类型实例化您的泛型构造来编写单元测试，然后就可以开始使用了！
在泛型不方便或不合适的情况下，例如，如果您想避免将类型的某个方面对用户通用，那么您可以将要模拟的状态和行为封装在一个专用的结构体中。然后，您将生成该结构体及其方法的模拟版本，并使用条件编译来根据 `cfg(test)` 或仅用于测试的功能（例如 `cfg(feature = "test_mock_foo")`）来使用真实实现或模拟实现。目前，Rust 社区中还没有一个模拟库，甚至没有一种模拟方法能够成为唯一正确的答案。我所知道的最全面、最全面的模拟库是 mockall crate，但它仍在积极开发中，还有许多其他竞争者。

### 仅测试代码

首先，使用仅测试代码可以让你向（单元）测试公开额外的方法、字段和类型，这样测试不仅可以检查公共 API 的行为是否正确，还可以检查内部状态是否正确。例如，考虑来自 `hashbrown` 的 `HashMap` 类型，它是实现标准库 HashMap 的 crate。HashMap 类型实际上只是 RawTable 类型的包装器，而 RawTable 类型实现了大部分哈希表逻辑。假设在一个空映射上执行 HashMap::insert 后，你想检查映射中某个存储桶是否非空，如清单 6-2 所示。

```rust
#[test]
fn insert_just_one() {
 let mut m = HashMap::new();
 m.insert(42, ());
 let full = m.table.buckets.iter().filter(Bucket::is_full).count();
 assert_eq!(full, 1);
}

// 清单 6-2：访问不可访问的内部状态并因此无法编译的测试
```
这段代码无法按原样编译，因为测试代码虽然可以访问 `HashMap` 的私有表字段，但却无法访问 `RawTable` 的私有 `buckets` 字段，因为 `RawTable` 位于另一个模块中。我们可以通过将 `buckets` 字段的可见性设置为 `pub(crate)` 来解决这个问题，但我们确实不希望 `HashMap` 能够访问 `buckets`，因为这可能会意外破坏 `RawTable` 的内部状态。即使将 `buckets` 设置为只读，也可能存在问题，因为 `HashMap` 中的新代码可能会依赖于 `RawTable` 的内部状态，从而增加将来修改的难度。解决方案是使用 `#[cfg(test)]`。我们可以向 `RawTable` 添加一个方法，只允许在测试期间访问 `buckets`，如示例 6-3 所示，从而避免给其余代码添加障碍。然后，可以更新示例 6-2 中的代码，使其调用 `buckets()` 而不是访问私有 buckets 字段。

```rust
impl RawTable {
 #[cfg(test)]
 pub(crate) fn buckets(&self) -> &[Bucket] {
 &self.buckets
 }
}

// 示例 6-3：使用 #[cfg(test)] 使内部状态在测试上下文中可访问
```

### 测试断言的记录

仅在测试期间存在代码的第二个好处是，您可以扩充程序以执行额外的运行时记录，然后可以通过测试进行检查。例如，假设您正在编写标准库中 `BufWriter` 类型的自定义版本。在测试它时，您需要确保 `BufWriter` 不会发出不必要的系统调用。最明显的方法是让 `BufWriter` 跟踪它在底层 `Write` 函数上调用 `write` 的次数。然而，在生产环境中，这些信息并不重要，跟踪这些信息会引入（边际的）性能和内存开销。使用 `#[cfg(test)]`，您可以让记录仅在测试时进行，如清单 6-4 所示。

```rust
struct BufWriter<T> {
 #[cfg(test)]
 write_through: usize,
 // other fields...
}
impl<T: Write> Write for BufWriter<T> {
 fn write(&mut self, buf: &[u8]) -> Result<usize> {
 // ...
 if self.full() {
 #[cfg(test)]
 self.write_through += 1;
 let n = self.inner.write(&self.buffer[..])?;
 // ...
 }
}

// 示例 6-4：使用 #[cfg(test)] 将簿记限制在测试上下文中
```
请记住，测试仅针对正在编译为测试的crate进行设置。对于单元测试，正如您所期望的那样，这是正在测试的crate。但是，对于集成测试，它是正在编译为测试的集成测试二进制文件——您正在测试的包只是作为库编译的，因此不会设置测试集。

## Doctests

文档注释中的 Rust 代码片段会自动作为测试用例运行。这些通常被称为 `doctest`。由于 `doctest` 出现在你的 crate 的公共文档中，并且用户可能会模仿它们包含的内容，因此它们会作为集成测试运行。这意味着 `doctest` 无法访问私有字段和方法，并且测试不会在主 crate 的代码中设置。每个 `doctest` 都会被编译为一个专用的 crate，并独立运行，就像用户将 `doctest` 复制粘贴到自己的程序中一样。编译器会在后台对 `doctest` 进行一些预处理，使其更简洁。最重要的是，它会自动在你的代码周围添加一个 `fn main`。这使得 `doctest` 可以只关注用户可能关心的重要部分，例如实际使用库中类型和方法的部分，而无需包含不必要的样板代码。

您可以通过在文档测试中定义自己的 `fn main` 来避免这种自动包装。例如，如果您想使用类似 `#[tokio::main] async fn main` 的异步 `main` 函数，或者想在文档测试中添加其他模块，您可能需要这样做。
要在文档测试中使用 `?` 运算符，通常无需使用自定义 `main` 函数，因为 `rustdoc` 包含一些启发式方法，可以将返回类型设置为 `Result<(), impl Debug>`。您的代码看起来像是使用了 `?` 运算符（例如，如果它以 `Ok(())` 结尾 。如果类型推断让您难以确定函数的错误类型，您可以通过将文档测试的最后一行更改为显式类型来消除歧义，如下所示：Ok::<(), T>(())。
文档测试具有许多附加功能，在为更复杂的接口编写文档时非常有用。首先是隐藏单行代码的功能。如果在文档测试的某一行前面加上 #，则该行会在文档测试编译和运行时被包含，但不会包含在文档生成的代码片段中。这让您可以轻松隐藏对当前示例不重要的细节，例如为虚拟类型实现特征或生成值。如果您希望呈现一系列示例，而不想每次都显示相同的前导代码，此功能也非常有用。清单 6-5 给出了一个隐藏行的文档测试示例。

```rust
/// Completely frobnifies a number through I/O.
///
/// In this first example we hide the value generation.
/// ```
/// # let unfrobnified_number = 0;
/// # let already_frobnified = 1;
/// assert!(frobnify(unfrobnified_number).is_ok());
/// assert!(frobnify(already_frobnified).is_err());
/// ```
///
/// Here's an example that uses ? on multiple types
/// and thus needs to declare the concrete error type,
/// but we don't want to distract the user with that.
/// We also hide the use that brings the function into scope.
/// ```
/// # use mylib::frobnify;
/// frobnify("0".parse()?)?;
/// # Ok::<(), anyhow::Error>(())
/// ```
///
/// You could even replace an entire block of code completely,
/// though use this _very_ sparingly:
/// ```
/// # /*
/// let i = ...;
/// # */
/// # let i = 42;
/// frobnify(i)?;
/// ```
fn frobnify(i: usize) -> std::io::Result<()> {

// 示例 6-5：使用 # 隐藏文档测试中的行
```
> 请谨慎使用此功能；如果用户复制粘贴示例，然后由于您隐藏了所需步骤而无法使用，这可能会让他们感到沮丧。

与 `#[test]` 函数非常相似，`doctest` 也支持修改 `doctest` 运行方式的属性。这些属性紧跟在用于表示代码块的三个反引号之后，多个属性可以用逗号分隔。与测试函数类似，您可以指定 `should_panic` 属性，指示特定 `doctest` 中的代码在运行时应该崩溃，或者`ignore` 属性仅在使用 `--ignored` 标志运行 `cargo test` 时才检查代码段。您还可以使用 `no_run` 属性，指示给定的 `doctest `应该编译但不应运行。
属性 `compile_fail` 告诉 `rustdoc` 文档示例中的代码不应编译。这向用户表明特定用途不可行，并可作为一个有用的测试，提醒您在库的相关方面发生变化时更新文档。您还可以使用此属性检查某些静态属性是否适用于您的类型。清单 6-6 展示了如何使用 `compile_fail` 来检查给定类型是否未实现 `Send` 的示例，这对于在不安全代码中维护安全保证可能是必要的。

`````rust
 ```compile_fail
# struct MyNonSendType(std::rc::Rc<()>);
fn is_send<T: Send>() {}
is_send::<MyNonSendType>();
 ```

// 示例 6-6：使用 compile_fail 测试代码编译失败
`````
compile_fail 是一个相当粗糙的工具，因为它无法提供任何代码无法编译的原因。例如，如果代码因为缺少分号而无法编译，那么 `compile_fail` 测试看起来会成功。
因此，通常只有在确认测试确实编译失败并出现预期错误后，才需要添加此属性。如果您需要更细粒度的编译错误测试，例如在开发宏时，请查看 `trybuild crate`。

## 其它测试工具

测试远不止运行测试函数并观察它们是否产生预期结果。本书不打算对测试技术、方法和工具进行全面概述，但有一些 Rust 特有的关键部分，在扩展你的测试知识库时，你应该了解。

### Linting

您可能不认为 Linter 的检查是测试，但在 Rust 中，它们通常可以算作测试。Rust Linter `Clippy` 将其许多 Lint 归类为正确性 Lint。这些 Lint 会捕获那些编译通过但几乎肯定是错误的代码模式。例如，`a = b; b = a`，无法交换 a 和 b；`std::mem::forget(t)`，其中 t 是引用；以及 `for x in y.next()`，它只会迭代 y 中的第一个元素。如果您尚未将 Clippy 作为 CI 管道的一部分运行，那么您应该这样做。
`Clippy` 附带了许多其他 Lint，虽然它们通常很有用，但可能比您期望的更偏向于主观。例如，默认情况下启用的 `type_complexity` lint 会在程序中使用特别复杂的类型（例如 `Rc<Vec<Vec<Box<(u32, u32, u32, u32)>>>>`）时发出警告。虽然该警告鼓励您编写更易于阅读的代码，但您可能会发现它过于繁琐，无法广泛使用。如果代码的某些部分错误地触发了特定的 lint，或者您只是想允许该 lint 的特定实例，则可以使用
`#[allow(clippy::name_of_lint)]` 禁用该代码段的 lint。Rust 编译器也自带了一组以警告形式出现的 lint，尽管这些警告通常更侧重于编写符合语法规范的代码，而不是检查正确性。相反，编译器中用于正确性的 lint 会被简单地视为错误（查看 rustc -W help 获取列表）。

> 并非所有编译器警告都默认启用。默认禁用的警告通常仍在完善中，或者更侧重于样式而非内容。一个很好的例子是“idiomatic Rust 2018 edition” lint，您可以使用 `#![warn(rust_2018_idioms)]` 启用它。启用此 lint 后，编译器会提示您是否未能充分利用 Rust 2018 版带来的更改。您可能希望在启动新项目时养成启用其他 lint 的习惯，例如 `missing_docs` 和 `missing_debug_implementations`，它们会在您忘记记录 crate 中的任何公共项目或为任何公共类型添加 Debug 实现时发出警告。

### Test Generation

编写一个好的测试套件需要大量的工作。即使你完成了这项工作，你编写的测试也只能测试你在编写时所考虑的特定行为集合。幸运的是，你可以利用多种测试生成技术来开发更好、更全面的测试。这些技术会生成输入，供你用来检查应用程序的正确性。市面上有很多这样的工具，每种工具都有各自的优缺点，因此这里我将仅介绍这些工具使用的主要策略：模糊测试和属性测试。

#### 模糊测试

关于模糊测试的书籍已经写了很多，但概括起来，模糊测试的思路很简单：为程序生成随机输入，看看它是否崩溃。如果程序崩溃了，那就是一个 bug。例如，如果你正在编写一个 URL 解析库，你可以通过系统地生成随机字符串，并将它们扔给解析函数，直到它崩溃来对程序进行模糊测试。如果这样做，可能需要一段时间才能得到结果：如果模糊测试器以 a 开头，然后是 b，然后是 c，依此类推，那么生成一个像 `http://[:]` 这样棘手的 URL 就需要很长时间。实际上，现代模糊测试器使用代码覆盖率指标来探索代码中的不同路径，这使得它们比真正随机选择输入更快地达到更高的覆盖率。模糊测试器非常擅长发现代码无法正确处理的奇怪极端情况。它们几乎不需要你进行任何设置：你只需将模糊测试器指向一个接受“可模糊测试”输入的函数，它就可以运行了。例如，清单 6-7 展示了一个如何对 URL 解析器进行模糊测试的示例。

```rust
libfuzzer_sys::fuzz_target!(|data: &[u8]| {
 if let Ok(s) = std::str::from_utf8(data) {
 let _ = url::Url::parse(s);
 }
});

// 清单 6-7：使用 libfuzzer 对 URL 解析器进行模糊测试
```

模糊测试器会为闭包生成半随机输入，任何构成有效 UTF-8 字符串的输入都会传递给解析器。请注意，这里的代码不会检查解析是否成功，而是会查找由于内部不变量被违反而导致解析器崩溃或崩溃的情况。模糊测试器会一直运行，直到您终止它，因此大多数模糊测试工具都内置了在测试一定数量的测试用例后停止的机制。如果您的输入不是易于模糊测试的类型（例如哈希表），通常可以使用类似`arbitrary`这样的crate将模糊测试器生成的字节字符串转换为更复杂的 Rust 类型。这听起来很神奇，但实际上它的实现方式非常简单。该包定义了一个 `Arbitrary trait`，其中包含一个方法 `arbitrary`，该方法从随机字节源构造实现类型。像 u32 或 bool 这样的原始类型会从输入中读取必要数量的字节，以构造自身的有效实例；而像 `HashMap` 或 `BTreeSet` 这样的更复杂的类型则会从输入中生成一个数字，以指定其长度，然后在其内部类型上调用 `Arbitrary` 函数，并按该次数调用。甚至还有一个属性 `#[derive(Arbitrary)]`，它只需对每个包含的类型调用 `Arbitrary` 函数即可实现 `Arbitrary` 函数！为了进一步探索模糊测试，我建议从 `cargo-fuzz` 开始。

#### 属性测试

有时，你不仅想检查程序是否崩溃，还想检查它是否按预期执行。你的 `add` 函数没有崩溃固然很好，但如果它告诉你 `add(1, 4)` 的结果为 68，那么它可能仍然是错的。这时，基于属性的测试就派上用场了；你描述代码应该遵循的一些属性，然后属性测试框架会生成输入并检查这些属性是否确实成立。

使用基于属性的测试的一种常见方法是，首先编写一个简单但朴素的待测试代码版本，并确信其正确性。然后，对于给定的输入，将该输入分别赋值给待测试代码和简化但朴素的版本。如果两个实现的结果或输出相同，则表明代码良好——这就是您所需的正确性属性——但如果结果不同，则很可能是发现了错误。
您还可以使用基于属性的测试来检查与正确性不直接相关的属性，例如，一个实现的操作是否比另一个实现的操作花费更少的时间。通用原则是，您希望真实版本和测试版本之间的任何结果差异都具有参考价值且可操作性，以便每次失败都能让您进行改进。
这个简单的实现可能是你试图替换或扩充的标准库中的实现（例如 `std::collections::VecDeque`），也可能是你试图优化的某个算法的简化版本（例如，简单矩阵乘法与优化矩阵乘法）。

如果这种生成输入直到满足某些条件的方法听起来很像模糊测试，那是因为它确实如此——一些比我更聪明的人认为模糊测试“只是”基于属性的测试，而你测试的属性是“它不会崩溃”。
基于属性的测试的一个缺点是它更依赖于提供的输入描述。模糊测试会不断尝试所有可能的输入，而属性测试则倾向于以开发者的注释为指导，例如“0 到 64 之间的数字”或“包含三个逗号的字符串”。这使得属性测试能够更快地找到模糊测试器可能需要很长时间才能随机遇到的情况，但它确实需要手动操作，并且可能会错过重要但小众的 bug 输入。然而，随着模糊测试器和属性测试器之间的联系越来越紧密，模糊测试器也开始获得这种基于约束的搜索能力。
如果您对基于属性的测试生成感兴趣，我建议您从 `proptest crate` 开始。

> 测试操作序列
由于模糊测试器和属性测试器允许您生成任意 Rust 类型，因此您不仅限于测试 crate 中的单个函数调用。例如，假设您想测试某个类型 Foo 在执行特定操作序列时是否能够正确运行。您可以定义一个枚举 Operation 来列出所有操作，并让测试函数接受 Vec<Operation> 参数。然后，您可以实例化一个 Foo 并对该 Foo 逐一执行每个操作。大多数测试器都支持最小化输入，因此如果发现违反属性的输入，他们甚至会搜索仍然违反属性的最小操作序列！

### 测试增强

假设你已经搭建好了一套出色的测试套件，你的代码也通过了所有测试。这真是太棒了。但有一天，一个通常可靠的测试莫名其妙地失败了，或者因为段错误而崩溃了。这类非确定性测试失败通常有两个原因：竞争条件（只有当两个操作以特定顺序在不同线程上发生时，你的测试才可能失败）；以及不安全代码中的未定义行为，例如某些不安全代码从未初始化的内存中读取了特定的值。用普通测试来捕获这类错误可能很困难——通常你没有足够的底层控制来编写可靠的测试，例如线程调度、内存布局和内容，或其他随机的系统因素。你可以在循环中多次运行每个测试，但如果错误情况足够罕见或不太可能发生，即使这样也可能无法捕获错误。幸运的是，有一些工具可以帮助增强你的测试，使捕获这类错误变得更容易。其中第一个是令人惊叹的工具 `Miri`，它是 Rust 中级中间表示 (MIR) 的解释器。MIR 是 Rust 的内部简化表示，它可以帮助编译器找到优化点并检查属性，而无需考虑 Rust 本身的所有语法糖。通过 `Miri` 运行测试就像运行 `cargo miri test` 一样简单。`Miri` 会解释您的代码，而不是像普通二进制文件那样编译和运行它，这会使测试运行速度明显变慢。但作为回报，`Miri` 可以在每行代码执行时跟踪整个程序的状态。这使得 `Miri` 能够检测并报告您的程序是否表现出某些类型的未定义行为，例如未初始化的内存读取、使用已丢弃的值或越界指针访问。`Miri` 会在这些操作发生时检测到并立即通知您，而不是让这些操作产生奇怪的程序行为，这些行为可能只是偶尔导致可观察到的测试失败（例如崩溃）。例如，考虑清单 6-8 中非常不合理的代码，它创建了对一个值的两个独占引用。

```rust
let mut x = 42;
let x: *mut i32 = &mut x;
let (x1, x2) = unsafe { (&mut *x, &mut *x) };
println!("{} {}", x1, x2);

// 清单 6-8：Miri 检测到的极不安全代码不正确
```
在撰写本文时，如果你通过 Miri 运行此代码，你会收到一条错误信息，指出具体出了什么问题：

```rust
error: Undefined Behavior: trying to reborrow for Unique at alloc1383, but
parent tag <2772> does not have an appropriate item in the borrow stack
 --> src/main.rs:4:6
 |
4 | let (x1, x2) = unsafe { (&mut *x, &mut *x) };
 | ^^ trying to reborrow for Unique at alloc1383, but parent tag <2772>
does not have an appropriate item in the borrow stack
```
> Miri 仍在开发中，其错误信息并不总是那么容易理解。我们正在积极解决这个问题，所以当你读到这篇文章的时候，错误输出可能已经变得更好了！

另一个值得关注的工具是 `Loom`，这是一个巧妙的库，它试图确保你的测试在每次相关的并发操作交错执行时都运行。从高层次上讲，`Loom` 会跟踪所有跨线程同步点，并反复运行你的测试，每次都会调整线程从这些同步点执行的顺序。因此，如果线程 A 和线程 B 都获取了同一个互斥锁，Loom 将确保测试运行一次，A 先获取，B 再获取。`Loom` 还会跟踪原子访问、内存排序以及对 `UnsafeCell`（我们将在第 9 章讨论）的访问，并检查线程是否以不适当的方式访问它们。如果测试失败，`Loom` 可以为你提供线程执行顺序的精确概要，以便你确定崩溃是如何发生的。

### 性能测试

编写性能测试很困难，因为通常很难准确地模拟出一个能够反映实际使用情况的工作负载。但拥有这样的测试非常重要；如果你的代码运行速度突然慢了 100 倍，那真的应该被视为一个 bug，但如果没有性能测试，你可能无法发现性能回归。如果你的代码运行速度快了 100 倍，那也可能表明存在问题。这两个原因都是将自动化性能测试作为持续集成 (CI) 的一部分的充分理由——如果性能在任何一个方向上发生剧烈变化，你都应该知道。
与功能测试不同，性能测试没有通用的、定义明确的输出。功能测试要么成功，要么失败，而性能测试可能会提供吞吐量数值、延迟配置文件、已处理的样本数量或任何其他可能与相关应用程序相关的指标。此外，性能测试可能需要循环运行某个函数数十万次，或者可能需要在多核计算机的分布式网络上运行数小时。
因此，很难笼统地谈论如何编写性能测试。在本节中，我们将探讨在 Rust 中编写性能测试时可能遇到的一些问题以及如何缓解这些问题。三个特别常见且经常被忽视的陷阱是性能差异、编译器优化和 I/O 开销。让我们逐一探讨这些问题。

#### 性能差异

性能会因各种各样的原因而发生变化，许多因素都会影响特定机器指令序列的运行速度。有些因素显而易见，例如 CPU 和内存的时钟速度，或者机器的负载，但很多因素则更加微妙。例如，内核版本可能会改变分页性能，用户名的长度可能会改变内存布局，室温可能会导致 CPU 时钟频率降低。最终，即使运行两次基准测试，获得相同的结果的可能性也很小。事实上，即使使用相同的硬件，也可能会观察到显著的差异。或者，从另一个角度来看，您的代码可能变慢了或变快了，但由于基准测试环境的差异，这种影响可能不可见。

除非你恰好能够在高度多样化的机器群上反复运行基准测试，否则没有完美的方法可以消除性能结果中的所有差异。即便如此，尽力处理这种测量差异，以便从基准测试提供的嘈杂测量结果中提取信号仍然至关重要。在实践中，我们应对差异的最佳方法是多次运行每个基准测试，然后查看测量值的分布，而不是仅仅查看单个测量值。Rust 有一些工具可以帮助我们做到这一点。例如，与其问“这个函数平均运行需要多长时间？”，像 `hdrhistogram` 这样的 crate 使我们能够查看诸如“哪个范围的运行时间覆盖了我们观察到的 95% 的样本？”之类的统计数据。为了更加严格，我们可以使用统计中的零假设检验等技术来建立一些信心，确保测量到的差异确实对应于真实的变化，而不仅仅是噪音。

关于统计假设检验的讲座超出了本书的范围，但幸运的是，这方面的大部分工作已经由其他人完成。例如，`criterion` crate 可以为您完成所有这些工作，甚至更多。您只需为它提供一个函数，让它可以调用该函数来运行基准测试的一次迭代，它就会运行适当的次数，以确保结果的可靠性。然后，它会生成一份基准测试报告，其中包含结果摘要、异常值分析，甚至还有随时间变化的趋势图形表示。当然，它无法消除仅在特定硬件配置上进行测试的影响，但它至少可以对执行过程中可测量的噪声进行分类。

#### 编译器优化

如今的编译器真是太聪明了。它们会消除死代码，在编译时计算复杂的表达式，展开循环，并执行其他“黑魔法”，从而榨干代码的每一点性能。通常情况下，这很有效，但当我们试图衡量一段特定代码的速度时，编译器的聪明之处可能会给出无效的结果。例如，对示例 6-9 中的 `Vec::push` 进行基准测试。

```rush
let mut vs = Vec::with_capacity(4);
let start = std::time::Instant::now();
for i in 0..4 {
 vs.push(i);
}
println!("took {:?}", start.elapsed());

// 清单 6-9：一个可疑的快速性能基准测试
```

如果你使用像 `godbolt.org` 或 `cargo-asm` 这样的优秀工具，查看这段代码在发布模式下编译的汇编输出，你会立即发现有些不对劲：`对 Vec::with _capacity` 和 `Vec::push` 的调用，以及整个 for 循环，都不见了。它们已经被完全优化掉了。编译器意识到，代码中实际上并不需要执行向量运算，因此将它们作为死代码删除。当然，编译器完全有权利这样做，但就基准测试而言，这并没有特别的帮助。

为了避免此类基准测试优化，标准库提供了 `std::hint::black_box`。该函数一直是备受争议和困惑的话题，在撰写本文时仍处于稳定阶段，但它非常有用，值得在此讨论。其核心是一个简单的恒等函数（接受 x 并返回 x），用于告诉编译器假设函数的参数以任意（合法）的方式使用。它不会阻止编译器对输入参数进行优化，也不会阻止编译器优化返回值的使用方式。相反，它鼓励编译器实际计算函数的参数（假设它会被使用），并将结果存储在 CPU 可访问的位置，以便可以使用计算值调用 `black_box`。编译器可以在编译时自由地计算输入参数，但它仍然应该将结果注入到程序中。

这个函数足以满足我们许多（尽管并非全部）基准测试的需求。例如，我们可以对示例 6-9 进行注释，这样向量访问就不再被优化掉，如示例 6-10 所示。

```rust
let mut vs = Vec::with_capacity(4);
let start = std::time::Instant::now();
for i in 0..4 {
 black_box(vs.as_ptr());
 vs.push(i);
 black_box(vs.as_ptr());
}
println!("took {:?}", start.elapsed());

// 清单 6-10：清单 6-9 的修正版本
```
我们已经告诉编译器，在循环的每次迭代中，无论是在 `push` 调用之前还是之后，`vs` 都会以任意方式被使用。这迫使编译器按顺序执行每次 push 操作，而不会合并或以其他方式优化连续的调用，因为它必须假设在每次调用之间，vs 可能会发生“任意无法优化的内容”（即 `black_box` 部分）。请注意，我们使用了 `vs.as_ptr()` 而不是 `&vs`。这是因为，
编译器应该假设 `black_box` 可以对其参数执行任何合法的操作。通过共享引用修改 `Vec` 是不合法的，因此，如果我们使用 `black_box(&vs)`，编译器可能会注意到 `vs` 在循环的迭代之间不会发生变化，并根据这一观察结果实施优化！

#### I/O开销测量

编写基准测试时，很容易意外地测量错误的内容。例如，我们经常希望实时获取基准测试的进展情况。为此，我们可能会编写类似示例 6-11 中的代码，用于测量 `my_function` 的运行速度：

```rust
let start = std::time::Instant::now();
for i in 0..1_000_000 {
 println!("iteration {}", i);
 my_function();
}
println!("took {:?}", start.elapsed());

// 清单 6-11：我们在这里真正要进行基准测试的是什么？
```

这看起来似乎达到了目标，但实际上，它并没有真正衡量 `my_function` 的速度。相反，这个循环很可能告诉我们打印一百万个数字需要多长时间。循环体中的 `println!` 在后台执行了大量工作：它将二进制整数转换为十进制数字以便打印，锁定标准输出，使用至少一个系统调用输出一系列 UTF-8 码位，然后释放标准输出锁。不仅如此，如果终端打印输入的速度很慢，系统调用可能会阻塞。这可是个很大的循环！而调用 `my_function` 所需的时间与之相比可能微不足道。当你的基准测试使用随机数时，也会发生类似的情况。如果你在循环中运行 `my_function(rand::random())`，你很可能主要测量的是生成一百万个随机数所需的时间。获取当前时间、读取配置文件或启动新线程也是如此——相对而言，这些操作都需要很长时间，并且最终可能会超过您实际想要测量的时间。幸运的是，一旦您意识到这个问题，通常很容易解决。确保基准测试循环的主体几乎只包含您想要测量的特定代码。所有其他代码应该在基准测试开始之前或基准测试的测量部分之外运行。如果您使用的是 `Criterion`，请查看它提供的不同计时循环——它们都是为了满足需要不同测量策略的基准测试用例而设计的！

# 总结

在本章中，我们详细探讨了 Rust 提供的内置测试功能。我们还学习了一些在测试 Rust 代码时非常有用的测试工具和技巧。这是本书中最后一章，重点介绍 Rust 中级应用的高级方面。从下一章（关于声明式宏和过程式宏）开始，我们将更加关注 Rust 代码。下一页再见！















