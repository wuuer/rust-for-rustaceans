# 第五章 测试

在本章中，我们将探讨扩展 Rust 测试功能的各种方法，以及您可能希望添加到测试组合中的其他测试类型。Rust 内置了许多内置测试工具，这些工具在《Rust 编程语言》中有详细介绍，主要体现在 `#[test]` 属性和 tests/ 目录下。这些工具适用于各种应用程序和规模，通常足以满足您启动项目所需的一切。然而，随着代码库的发展和测试需求的日益复杂，您可能需要做的不仅仅是在各个函数上添加 `#[test]` 标签。本章分为两部分。第一部分介绍 Rust 测试机制，例如标准测试工具和条件测试代码。第二部分介绍评估 Rust 代码正确性的其他方法，例如基准测试、linting 和模糊测试。

## 测试运行机制

要理解 Rust 提供的各种测试机制，首先必须了解 Rust 如何构建和运行测试。运行 `cargo test --lib` 时，Cargo 唯一特别之处是将 `--test` 标志传递给 `rustc`。此标志指示 rustc 生成一个运行所有单元测试的测试二进制文件，而不是仅仅编译 crate 的库或二进制文件。在后台，`--test` 有两个主要作用。首先，它启用 `cfg(test) `，以便您可以有条件地包含测试代码（稍后会详细介绍）。其次，它使编译器生成一个测试工具：一个精心生成的 `main` 函数，它会在程序运行时调用每个
`#[test]` 函数。

### 测试工具

编译器通过一系列过程宏（我们将在第 7 章更深入地讨论）和少量的魔法来生成测试工具的主函数。本质上，测试工具将每个以 `#[test]` 注释的函数转换为测试描述符——这是过程宏的部分。然后，它将每个描述符的路径暴露给生成的主函数——这是魔法的部分。描述符包含测试名称、设置的任何附加选项（例如 `#[should_panic]`）等信息。测试工具的核心是迭代 crate 中的测试，运行它们，捕获它们的结果并打印结果。因此，它还包含解析命令行参数（例如 `--test-threads=1`）、捕获测试输出、并行运行列出的测试以及收集测试结果的逻辑。

截至撰写本文时，Rust 开发者正在努力将测试工具生成的关键部分变成一个公开可用的 API，以便开发者可以构建自己的测试工具。这项工作仍处于实验阶段，但该提案与目前的模型非常契合。需要解决的部分关键问题是如何确保 `#[test]` 函数即使位于私有子模块中，也能被生成的主函数使用。

集成测试（tests/ 中的测试）遵循与单元测试相同的流程，但有一个例外：它们各自被编译为独立的 crate，这意味着它们只能访问主 crate 的公共接口，并且针对未使用 `#[cfg(test)` 编译的主 crate 运行。tests/ 中的每个文件都会生成一个测试工具。子目录中的文件不会生成测试工具。

> 如果您明确需要对子目录中的文件进行测试，您可以通过调用文件 main.rs 来选择加入。

Rust 不要求您使用默认的测试工具。您可以选择不使用默认的测试工具，并实现自己的 `main` 方法，通过在 `Cargo.toml` 中为给定的集成测试设置 `harness = false` 来代表测试运行器，如清单 6-1 所示。然后，您定义的 main 方法将被调用来运行测试。

```rust
[[test]]
name = "custom"
path = "tests/custom.rs"
harness = false

// 清单 6-1：退出标准测试工具
```
如果没有测试工具，`#[test]` 周围的所有魔法都无法实现。相反，您需要编写自己的 `main` 函数来运行您想要执行的测试代码。本质上，您编写的是一个普通的 Rust 二进制文件，只不过它恰好由 `Cargo Test` 运行。该二进制文件负责处理默认工具通常执行的所有操作（如果您希望支持它们），例如命令行标志。每个集成测试的 harness 属性都是单独设置的，
因此，您可以拥有一个使用标准工具的测试文件，以及一个不使用标准工具的测试文件。

> 默认测试工具的参数
> 
> 默认测试工具支持许多命令行参数，用于配置测试的运行方式。这些参数不会直接传递给 `Cargo test`，而是传递给 `Cargo` 在您运行 `Cargo test` 时为您编译和运行的测试二进制文件。要访问这组参数，请将 `--` 传递给 `Cargo test`，然后将参数传递给测试二进制文件。例如，要查看测试二进制文件的帮助文本，请运行 `Cargo test -- --help`。
通过这些命令行参数，您可以使用许多便捷的配置选项。`--nocapture` 标志禁用运行 Rust 测试时通常会进行的输出捕获。如果您想实时观察测试的输出，而不是在测试失败后一次性全部观察，这将非常有用。您可以使用 `--test-threads` 选项来限制同时运行的测试数量，如果您的测试挂起或出现段错误，并且您想通过顺序运行测试来找出是哪个错误，这将非常有用。还有一个 `--skip` 选项，用于跳过符合特定模式的测试；`--ignored` 选项用于运行通常会被忽略的测试（例如需要运行外部程序的测试）；以及 `--list` 选项，用于列出所有可用的测试。
请记住，这些参数都是由默认测试工具实现的，因此如果您禁用它（使用 `harness = false`），则必须在主函数中自行实现所需的参数！

无需 Harness 的集成测试主要用于基准性能测试，我们稍后会看到，但当您想要运行不符合标准“一个函数，一个测试”模型的测试时，它们也会派上用场。例如，您经常会看到无 Harness 测试与模糊测试器、模型检查器以及需要自定义全局设置的测试（例如在 WebAssembly 下或使用自定义目标时）一起使用。

### #[cfg(test)]
Rust 在构建测试代码时，会设置编译器配置标志 `test`，然后您可以使用该标志与条件编译一起使用，以便将代码编译出来，除非是专门用于测试的代码。表面上看，这似乎很奇怪：难道您不想测试即将投入生产的代码吗？您当然想，但拥有专门用于测试的代码，可以让您通过几种方式编写更好、更全面的测试。

> 模拟
> 编写测试时，您通常希望对正在测试的代码以及代码可能与之交互的任何其他类型进行严格控制。例如，如果您正在测试网络客户端，您可能不想在真实网络上运行单元测试，而是希望直接控制“网络”发出的字节数以及时间。或者，如果您正在测试数据结构，您希望测试使用能够控制每个方法在每次调用时返回内容的类型。您可能还希望收集一些指标，例如给定方法的调用频率或是否发出了给定的字节序列。这些“伪”类型和实现被称为模拟，它们是任何广泛的单元测试套件的关键特性。虽然您通常可以手动完成获得这种控制所需的工作，但最好让一个库来为您处理大部分细节。这就是自动模拟发挥作用的地方。模拟库将提供生成具有特定属性或签名的类型（包括函数）的功能，以及在测试执行期间控制和自省这些生成项的机制。
Rust 中的模拟通常通过泛型进行——只要您的程序、数据结构、框架或工具对您想要模拟的任何内容（或接受特征对象）是泛型的，您就可以使用模拟库生成符合规范的类型，这些类型将实例化这些泛型参数。然后，您可以使用生成的模拟类型实例化您的泛型构造来编写单元测试，然后就可以开始使用了！
在泛型不方便或不合适的情况下，例如，如果您想避免将类型的某个方面对用户通用，那么您可以将要模拟的状态和行为封装在一个专用的结构体中。然后，您将生成该结构体及其方法的模拟版本，并使用条件编译来根据 `cfg(test)` 或仅用于测试的功能（例如 `cfg(feature = "test_mock_foo")`）来使用真实实现或模拟实现。目前，Rust 社区中还没有一个模拟库，甚至没有一种模拟方法能够成为唯一正确的答案。我所知道的最全面、最全面的模拟库是 mockall crate，但它仍在积极开发中，还有许多其他竞争者。

### 仅测试代码

首先，使用仅测试代码可以让你向（单元）测试公开额外的方法、字段和类型，这样测试不仅可以检查公共 API 的行为是否正确，还可以检查内部状态是否正确。例如，考虑来自 `hashbrown` 的 `HashMap` 类型，它是实现标准库 HashMap 的 crate。HashMap 类型实际上只是 RawTable 类型的包装器，而 RawTable 类型实现了大部分哈希表逻辑。假设在一个空映射上执行 HashMap::insert 后，你想检查映射中某个存储桶是否非空，如清单 6-2 所示。

```rust
#[test]
fn insert_just_one() {
 let mut m = HashMap::new();
 m.insert(42, ());
 let full = m.table.buckets.iter().filter(Bucket::is_full).count();
 assert_eq!(full, 1);
}

// 清单 6-2：访问不可访问的内部状态并因此无法编译的测试
```
这段代码无法按原样编译，因为测试代码虽然可以访问 `HashMap` 的私有表字段，但却无法访问 `RawTable` 的私有 `buckets` 字段，因为 `RawTable` 位于另一个模块中。我们可以通过将 `buckets` 字段的可见性设置为 `pub(crate)` 来解决这个问题，但我们确实不希望 `HashMap` 能够访问 `buckets`，因为这可能会意外破坏 `RawTable` 的内部状态。即使将 `buckets` 设置为只读，也可能存在问题，因为 `HashMap` 中的新代码可能会依赖于 `RawTable` 的内部状态，从而增加将来修改的难度。解决方案是使用 `#[cfg(test)]`。我们可以向 `RawTable` 添加一个方法，只允许在测试期间访问 `buckets`，如示例 6-3 所示，从而避免给其余代码添加障碍。然后，可以更新示例 6-2 中的代码，使其调用 `buckets()` 而不是访问私有 buckets 字段。

```rust
impl RawTable {
 #[cfg(test)]
 pub(crate) fn buckets(&self) -> &[Bucket] {
 &self.buckets
 }
}

// 示例 6-3：使用 #[cfg(test)] 使内部状态在测试上下文中可访问
```

### 测试断言的记录

仅在测试期间存在代码的第二个好处是，您可以扩充程序以执行额外的运行时记录，然后可以通过测试进行检查。例如，假设您正在编写标准库中 `BufWriter` 类型的自定义版本。在测试它时，您需要确保 `BufWriter` 不会发出不必要的系统调用。最明显的方法是让 `BufWriter` 跟踪它在底层 `Write` 函数上调用 `write` 的次数。然而，在生产环境中，这些信息并不重要，跟踪这些信息会引入（边际的）性能和内存开销。使用 `#[cfg(test)]`，您可以让记录仅在测试时进行，如清单 6-4 所示。

```rust
struct BufWriter<T> {
 #[cfg(test)]
 write_through: usize,
 // other fields...
}
impl<T: Write> Write for BufWriter<T> {
 fn write(&mut self, buf: &[u8]) -> Result<usize> {
 // ...
 if self.full() {
 #[cfg(test)]
 self.write_through += 1;
 let n = self.inner.write(&self.buffer[..])?;
 // ...
 }
}

// 示例 6-4：使用 #[cfg(test)] 将簿记限制在测试上下文中
```
请记住，测试仅针对正在编译为测试的crate进行设置。对于单元测试，正如您所期望的那样，这是正在测试的crate。但是，对于集成测试，它是正在编译为测试的集成测试二进制文件——您正在测试的包只是作为库编译的，因此不会设置测试集。

## Doctests

文档注释中的 Rust 代码片段会自动作为测试用例运行。这些通常被称为 `doctest`。由于 `doctest` 出现在你的 crate 的公共文档中，并且用户可能会模仿它们包含的内容，因此它们会作为集成测试运行。这意味着 `doctest` 无法访问私有字段和方法，并且测试不会在主 crate 的代码中设置。每个 `doctest` 都会被编译为一个专用的 crate，并独立运行，就像用户将 `doctest` 复制粘贴到自己的程序中一样。编译器会在后台对 `doctest` 进行一些预处理，使其更简洁。最重要的是，它会自动在你的代码周围添加一个 `fn main`。这使得 `doctest` 可以只关注用户可能关心的重要部分，例如实际使用库中类型和方法的部分，而无需包含不必要的样板代码。

您可以通过在文档测试中定义自己的 `fn main` 来避免这种自动包装。例如，如果您想使用类似 `#[tokio::main] async fn main` 的异步 `main` 函数，或者想在文档测试中添加其他模块，您可能需要这样做。
要在文档测试中使用 `?` 运算符，通常无需使用自定义 `main` 函数，因为 `rustdoc` 包含一些启发式方法，可以将返回类型设置为 `Result<(), impl Debug>`。您的代码看起来像是使用了 `?` 运算符（例如，如果它以 `Ok(())` 结尾 。如果类型推断让您难以确定函数的错误类型，您可以通过将文档测试的最后一行更改为显式类型来消除歧义，如下所示：Ok::<(), T>(())。
文档测试具有许多附加功能，在为更复杂的接口编写文档时非常有用。首先是隐藏单行代码的功能。如果在文档测试的某一行前面加上 #，则该行会在文档测试编译和运行时被包含，但不会包含在文档生成的代码片段中。这让您可以轻松隐藏对当前示例不重要的细节，例如为虚拟类型实现特征或生成值。如果您希望呈现一系列示例，而不想每次都显示相同的前导代码，此功能也非常有用。清单 6-5 给出了一个隐藏行的文档测试示例。

```rust
/// Completely frobnifies a number through I/O.
///
/// In this first example we hide the value generation.
/// ```
/// # let unfrobnified_number = 0;
/// # let already_frobnified = 1;
/// assert!(frobnify(unfrobnified_number).is_ok());
/// assert!(frobnify(already_frobnified).is_err());
/// ```
///
/// Here's an example that uses ? on multiple types
/// and thus needs to declare the concrete error type,
/// but we don't want to distract the user with that.
/// We also hide the use that brings the function into scope.
/// ```
/// # use mylib::frobnify;
/// frobnify("0".parse()?)?;
/// # Ok::<(), anyhow::Error>(())
/// ```
///
/// You could even replace an entire block of code completely,
/// though use this _very_ sparingly:
/// ```
/// # /*
/// let i = ...;
/// # */
/// # let i = 42;
/// frobnify(i)?;
/// ```
fn frobnify(i: usize) -> std::io::Result<()> {

// 示例 6-5：使用 # 隐藏文档测试中的行
```
> 请谨慎使用此功能；如果用户复制粘贴示例，然后由于您隐藏了所需步骤而无法使用，这可能会让他们感到沮丧。

与 `#[test]` 函数非常相似，`doctest` 也支持修改 `doctest` 运行方式的属性。这些属性紧跟在用于表示代码块的三个反引号之后，多个属性可以用逗号分隔。与测试函数类似，您可以指定 `should_panic` 属性，指示特定 `doctest` 中的代码在运行时应该崩溃，或者`ignore` 属性仅在使用 `--ignored` 标志运行 `cargo test` 时才检查代码段。您还可以使用 `no_run` 属性，指示给定的 `doctest `应该编译但不应运行。
属性 `compile_fail` 告诉 `rustdoc` 文档示例中的代码不应编译。这向用户表明特定用途不可行，并可作为一个有用的测试，提醒您在库的相关方面发生变化时更新文档。您还可以使用此属性检查某些静态属性是否适用于您的类型。清单 6-6 展示了如何使用 `compile_fail` 来检查给定类型是否未实现 `Send` 的示例，这对于在不安全代码中维护安全保证可能是必要的。

`````rust
 ```compile_fail
# struct MyNonSendType(std::rc::Rc<()>);
fn is_send<T: Send>() {}
is_send::<MyNonSendType>();
 ```

// 示例 6-6：使用 compile_fail 测试代码编译失败
`````
compile_fail 是一个相当粗糙的工具，因为它无法提供任何代码无法编译的原因。例如，如果代码因为缺少分号而无法编译，那么 `compile_fail` 测试看起来会成功。
因此，通常只有在确认测试确实编译失败并出现预期错误后，才需要添加此属性。如果您需要更细粒度的编译错误测试，例如在开发宏时，请查看 `trybuild crate`。

## 其它测试工具

测试远不止运行测试函数并观察它们是否产生预期结果。本书不打算对测试技术、方法和工具进行全面概述，但有一些 Rust 特有的关键部分，在扩展你的测试知识库时，你应该了解。

### Linting

您可能不认为 Linter 的检查是测试，但在 Rust 中，它们通常可以算作测试。Rust Linter `Clippy` 将其许多 Lint 归类为正确性 Lint。这些 Lint 会捕获那些编译通过但几乎肯定是错误的代码模式。例如，`a = b; b = a`，无法交换 a 和 b；`std::mem::forget(t)`，其中 t 是引用；以及 `for x in y.next()`，它只会迭代 y 中的第一个元素。如果您尚未将 Clippy 作为 CI 管道的一部分运行，那么您应该这样做。
`Clippy` 附带了许多其他 Lint，虽然它们通常很有用，但可能比您期望的更偏向于主观。例如，默认情况下启用的 `type_complexity` lint 会在程序中使用特别复杂的类型（例如 `Rc<Vec<Vec<Box<(u32, u32, u32, u32)>>>>`）时发出警告。虽然该警告鼓励您编写更易于阅读的代码，但您可能会发现它过于繁琐，无法广泛使用。如果代码的某些部分错误地触发了特定的 lint，或者您只是想允许该 lint 的特定实例，则可以使用
`#[allow(clippy::name_of_lint)]` 禁用该代码段的 lint。Rust 编译器也自带了一组以警告形式出现的 lint，尽管这些警告通常更侧重于编写符合语法规范的代码，而不是检查正确性。相反，编译器中用于正确性的 lint 会被简单地视为错误（查看 rustc -W help 获取列表）。

> 并非所有编译器警告都默认启用。默认禁用的警告通常仍在完善中，或者更侧重于样式而非内容。一个很好的例子是“idiomatic Rust 2018 edition” lint，您可以使用 `#![warn(rust_2018_idioms)]` 启用它。启用此 lint 后，编译器会提示您是否未能充分利用 Rust 2018 版带来的更改。您可能希望在启动新项目时养成启用其他 lint 的习惯，例如 `missing_docs` 和 `missing_debug_implementations`，它们会在您忘记记录 crate 中的任何公共项目或为任何公共类型添加 Debug 实现时发出警告。

### Test Generation

编写一个好的测试套件需要大量的工作。即使你完成了这项工作，你编写的测试也只能测试你在编写时所考虑的特定行为集合。幸运的是，你可以利用多种测试生成技术来开发更好、更全面的测试。这些技术会生成输入，供你用来检查应用程序的正确性。市面上有很多这样的工具，每种工具都有各自的优缺点，因此这里我将仅介绍这些工具使用的主要策略：模糊测试和属性测试。

#### 模糊测试

关于模糊测试的书籍已经写了很多，但概括起来，模糊测试的思路很简单：为程序生成随机输入，看看它是否崩溃。如果程序崩溃了，那就是一个 bug。例如，如果你正在编写一个 URL 解析库，你可以通过系统地生成随机字符串，并将它们扔给解析函数，直到它崩溃来对程序进行模糊测试。如果这样做，可能需要一段时间才能得到结果：如果模糊测试器以 a 开头，然后是 b，然后是 c，依此类推，那么生成一个像 `http://[:]` 这样棘手的 URL 就需要很长时间。实际上，现代模糊测试器使用代码覆盖率指标来探索代码中的不同路径，这使得它们比真正随机选择输入更快地达到更高的覆盖率。模糊测试器非常擅长发现代码无法正确处理的奇怪极端情况。它们几乎不需要你进行任何设置：你只需将模糊测试器指向一个接受“可模糊测试”输入的函数，它就可以运行了。例如，清单 6-7 展示了一个如何对 URL 解析器进行模糊测试的示例。

```rust
libfuzzer_sys::fuzz_target!(|data: &[u8]| {
 if let Ok(s) = std::str::from_utf8(data) {
 let _ = url::Url::parse(s);
 }
});

// 清单 6-7：使用 libfuzzer 对 URL 解析器进行模糊测试
```

模糊测试器会为闭包生成半随机输入，任何构成有效 UTF-8 字符串的输入都会传递给解析器。请注意，这里的代码不会检查解析是否成功，而是会查找由于内部不变量被违反而导致解析器崩溃或崩溃的情况。模糊测试器会一直运行，直到您终止它，因此大多数模糊测试工具都内置了在测试一定数量的测试用例后停止的机制。如果您的输入不是易于模糊测试的类型（例如哈希表），通常可以使用类似`arbitrary`这样的crate将模糊测试器生成的字节字符串转换为更复杂的 Rust 类型。这听起来很神奇，但实际上它的实现方式非常简单。该包定义了一个 `Arbitrary trait`，其中包含一个方法 `arbitrary`，该方法从随机字节源构造实现类型。像 u32 或 bool 这样的原始类型会从输入中读取必要数量的字节，以构造自身的有效实例；而像 `HashMap` 或 `BTreeSet` 这样的更复杂的类型则会从输入中生成一个数字，以指定其长度，然后在其内部类型上调用 `Arbitrary` 函数，并按该次数调用。甚至还有一个属性 `#[derive(Arbitrary)]`，它只需对每个包含的类型调用 `Arbitrary` 函数即可实现 `Arbitrary` 函数！为了进一步探索模糊测试，我建议从 `cargo-fuzz` 开始。

#### 属性测试

有时，你不仅想检查程序是否崩溃，还想检查它是否按预期执行。你的 `add` 函数没有崩溃固然很好，但如果它告诉你 `add(1, 4)` 的结果为 68，那么它可能仍然是错的。这时，基于属性的测试就派上用场了；你描述代码应该遵循的一些属性，然后属性测试框架会生成输入并检查这些属性是否确实成立。

使用基于属性的测试的一种常见方法是，首先编写一个简单但朴素的待测试代码版本，并确信其正确性。然后，对于给定的输入，将该输入分别赋值给待测试代码和简化但朴素的版本。如果两个实现的结果或输出相同，则表明代码良好——这就是您所需的正确性属性——但如果结果不同，则很可能是发现了错误。
您还可以使用基于属性的测试来检查与正确性不直接相关的属性，例如，一个实现的操作是否比另一个实现的操作花费更少的时间。通用原则是，您希望真实版本和测试版本之间的任何结果差异都具有参考价值且可操作性，以便每次失败都能让您进行改进。
这个简单的实现可能是你试图替换或扩充的标准库中的实现（例如 `std::collections::VecDeque`），也可能是你试图优化的某个算法的简化版本（例如，简单矩阵乘法与优化矩阵乘法）。

如果这种生成输入直到满足某些条件的方法听起来很像模糊测试，那是因为它确实如此——一些比我更聪明的人认为模糊测试“只是”基于属性的测试，而你测试的属性是“它不会崩溃”。
基于属性的测试的一个缺点是它更依赖于提供的输入描述。模糊测试会不断尝试所有可能的输入，而属性测试则倾向于以开发者的注释为指导，例如“0 到 64 之间的数字”或“包含三个逗号的字符串”。这使得属性测试能够更快地找到模糊测试器可能需要很长时间才能随机遇到的情况，但它确实需要手动操作，并且可能会错过重要但小众的 bug 输入。然而，随着模糊测试器和属性测试器之间的联系越来越紧密，模糊测试器也开始获得这种基于约束的搜索能力。
如果您对基于属性的测试生成感兴趣，我建议您从 `proptest crate` 开始。

> 测试操作序列
由于模糊测试器和属性测试器允许您生成任意 Rust 类型，因此您不仅限于测试 crate 中的单个函数调用。例如，假设您想测试某个类型 Foo 在执行特定操作序列时是否能够正确运行。您可以定义一个枚举 Operation 来列出所有操作，并让测试函数接受 Vec<Operation> 参数。然后，您可以实例化一个 Foo 并对该 Foo 逐一执行每个操作。大多数测试器都支持最小化输入，因此如果发现违反属性的输入，他们甚至会搜索仍然违反属性的最小操作序列！














