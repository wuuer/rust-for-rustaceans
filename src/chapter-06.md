# 第五章 测试

在本章中，我们将探讨扩展 Rust 测试功能的各种方法，以及您可能希望添加到测试组合中的其他测试类型。Rust 内置了许多内置测试工具，这些工具在《Rust 编程语言》中有详细介绍，主要体现在 `#[test]` 属性和 tests/ 目录下。这些工具适用于各种应用程序和规模，通常足以满足您启动项目所需的一切。然而，随着代码库的发展和测试需求的日益复杂，您可能需要做的不仅仅是在各个函数上添加 `#[test]` 标签。本章分为两部分。第一部分介绍 Rust 测试机制，例如标准测试工具和条件测试代码。第二部分介绍评估 Rust 代码正确性的其他方法，例如基准测试、linting 和模糊测试。

## 测试运行机制

要理解 Rust 提供的各种测试机制，首先必须了解 Rust 如何构建和运行测试。运行 `cargo test --lib` 时，Cargo 唯一特别之处是将 `--test` 标志传递给 `rustc`。此标志指示 rustc 生成一个运行所有单元测试的测试二进制文件，而不是仅仅编译 crate 的库或二进制文件。在后台，`--test` 有两个主要作用。首先，它启用 `cfg(test) `，以便您可以有条件地包含测试代码（稍后会详细介绍）。其次，它使编译器生成一个测试工具：一个精心生成的 `main` 函数，它会在程序运行时调用每个
`#[test]` 函数。

## 测试工具

编译器通过一系列过程宏（我们将在第 7 章更深入地讨论）和少量的魔法来生成测试工具的主函数。本质上，测试工具将每个以 `#[test]` 注释的函数转换为测试描述符——这是过程宏的部分。然后，它将每个描述符的路径暴露给生成的主函数——这是魔法的部分。描述符包含测试名称、设置的任何附加选项（例如 `#[should_panic]`）等信息。测试工具的核心是迭代 crate 中的测试，运行它们，捕获它们的结果并打印结果。因此，它还包含解析命令行参数（例如 `--test-threads=1`）、捕获测试输出、并行运行列出的测试以及收集测试结果的逻辑。

截至撰写本文时，Rust 开发者正在努力将测试工具生成的关键部分变成一个公开可用的 API，以便开发者可以构建自己的测试工具。这项工作仍处于实验阶段，但该提案与目前的模型非常契合。需要解决的部分关键问题是如何确保 `#[test]` 函数即使位于私有子模块中，也能被生成的主函数使用。

集成测试（tests/ 中的测试）遵循与单元测试相同的流程，但有一个例外：它们各自被编译为独立的 crate，这意味着它们只能访问主 crate 的公共接口，并且针对未使用 `#[cfg(test)` 编译的主 crate 运行。tests/ 中的每个文件都会生成一个测试工具。子目录中的文件不会生成测试工具。

> 如果您明确需要对子目录中的文件进行测试，您可以通过调用文件 main.rs 来选择加入。

Rust 不要求您使用默认的测试工具。您可以选择不使用默认的测试工具，并实现自己的 `main` 方法，通过在 `Cargo.toml` 中为给定的集成测试设置 `harness = false` 来代表测试运行器，如清单 6-1 所示。然后，您定义的 main 方法将被调用来运行测试。

```rust
[[test]]
name = "custom"
path = "tests/custom.rs"
harness = false

// 清单 6-1：退出标准测试工具
```
如果没有测试工具，`#[test]` 周围的所有魔法都无法实现。相反，您需要编写自己的 `main` 函数来运行您想要执行的测试代码。本质上，您编写的是一个普通的 Rust 二进制文件，只不过它恰好由 `Cargo Test` 运行。该二进制文件负责处理默认工具通常执行的所有操作（如果您希望支持它们），例如命令行标志。每个集成测试的 harness 属性都是单独设置的，
因此，您可以拥有一个使用标准工具的测试文件，以及一个不使用标准工具的测试文件。

> 默认测试工具的参数
> 
> 默认测试工具支持许多命令行参数，用于配置测试的运行方式。这些参数不会直接传递给 `Cargo test`，而是传递给 `Cargo` 在您运行 `Cargo test` 时为您编译和运行的测试二进制文件。要访问这组参数，请将 `--` 传递给 `Cargo test`，然后将参数传递给测试二进制文件。例如，要查看测试二进制文件的帮助文本，请运行 `Cargo test -- --help`。
通过这些命令行参数，您可以使用许多便捷的配置选项。`--nocapture` 标志禁用运行 Rust 测试时通常会进行的输出捕获。如果您想实时观察测试的输出，而不是在测试失败后一次性全部观察，这将非常有用。您可以使用 `--test-threads` 选项来限制同时运行的测试数量，如果您的测试挂起或出现段错误，并且您想通过顺序运行测试来找出是哪个错误，这将非常有用。还有一个 `--skip` 选项，用于跳过符合特定模式的测试；`--ignored` 选项用于运行通常会被忽略的测试（例如需要运行外部程序的测试）；以及 `--list` 选项，用于列出所有可用的测试。
请记住，这些参数都是由默认测试工具实现的，因此如果您禁用它（使用 `harness = false`），则必须在主函数中自行实现所需的参数！

无需 Harness 的集成测试主要用于基准性能测试，我们稍后会看到，但当您想要运行不符合标准“一个函数，一个测试”模型的测试时，它们也会派上用场。例如，您经常会看到无 Harness 测试与模糊测试器、模型检查器以及需要自定义全局设置的测试（例如在 WebAssembly 下或使用自定义目标时）一起使用。

## #[cfg(test)]
Rust 在构建测试代码时，会设置编译器配置标志 `test`，然后您可以使用该标志与条件编译一起使用，以便将代码编译出来，除非是专门用于测试的代码。表面上看，这似乎很奇怪：难道您不想测试即将投入生产的代码吗？您当然想，但拥有专门用于测试的代码，可以让您通过几种方式编写更好、更全面的测试。

> 模拟
> 编写测试时，您通常希望对正在测试的代码以及代码可能与之交互的任何其他类型进行严格控制。例如，如果您正在测试网络客户端，您可能不想在真实网络上运行单元测试，而是希望直接控制“网络”发出的字节数以及时间。或者，如果您正在测试数据结构，您希望测试使用能够控制每个方法在每次调用时返回内容的类型。您可能还希望收集一些指标，例如给定方法的调用频率或是否发出了给定的字节序列。这些“伪”类型和实现被称为模拟，它们是任何广泛的单元测试套件的关键特性。虽然您通常可以手动完成获得这种控制所需的工作，但最好让一个库来为您处理大部分细节。这就是自动模拟发挥作用的地方。模拟库将提供生成具有特定属性或签名的类型（包括函数）的功能，以及在测试执行期间控制和自省这些生成项的机制。
Rust 中的模拟通常通过泛型进行——只要您的程序、数据结构、框架或工具对您想要模拟的任何内容（或接受特征对象）是泛型的，您就可以使用模拟库生成符合规范的类型，这些类型将实例化这些泛型参数。然后，您可以使用生成的模拟类型实例化您的泛型构造来编写单元测试，然后就可以开始使用了！
在泛型不方便或不合适的情况下，例如，如果您想避免将类型的某个方面对用户通用，那么您可以将要模拟的状态和行为封装在一个专用的结构体中。然后，您将生成该结构体及其方法的模拟版本，并使用条件编译来根据 `cfg(test)` 或仅用于测试的功能（例如 `cfg(feature = "test_mock_foo")`）来使用真实实现或模拟实现。目前，Rust 社区中还没有一个模拟库，甚至没有一种模拟方法能够成为唯一正确的答案。我所知道的最全面、最全面的模拟库是 mockall crate，但它仍在积极开发中，还有许多其他竞争者。

### 仅测试代码

首先，使用仅测试代码可以让你向（单元）测试公开额外的方法、字段和类型，这样测试不仅可以检查公共 API 的行为是否正确，还可以检查内部状态是否正确。例如，考虑来自 `hashbrown` 的 `HashMap` 类型，它是实现标准库 HashMap 的 crate。HashMap 类型实际上只是 RawTable 类型的包装器，而 RawTable 类型实现了大部分哈希表逻辑。假设在一个空映射上执行 HashMap::insert 后，你想检查映射中某个存储桶是否非空，如清单 6-2 所示。

```rust
#[test]
fn insert_just_one() {
 let mut m = HashMap::new();
 m.insert(42, ());
 let full = m.table.buckets.iter().filter(Bucket::is_full).count();
 assert_eq!(full, 1);
}

// 清单 6-2：访问不可访问的内部状态并因此无法编译的测试
```
这段代码无法按原样编译，因为测试代码虽然可以访问 `HashMap` 的私有表字段，但却无法访问 `RawTable` 的私有 `buckets` 字段，因为 `RawTable` 位于另一个模块中。我们可以通过将 `buckets` 字段的可见性设置为 `pub(crate)` 来解决这个问题，但我们确实不希望 `HashMap` 能够访问 `buckets`，因为这可能会意外破坏 `RawTable` 的内部状态。即使将 `buckets` 设置为只读，也可能存在问题，因为 `HashMap` 中的新代码可能会依赖于 `RawTable` 的内部状态，从而增加将来修改的难度。解决方案是使用 `#[cfg(test)]`。我们可以向 `RawTable` 添加一个方法，只允许在测试期间访问 `buckets`，如示例 6-3 所示，从而避免给其余代码添加障碍。然后，可以更新示例 6-2 中的代码，使其调用 `buckets()` 而不是访问私有 buckets 字段。

```rust
impl RawTable {
 #[cfg(test)]
 pub(crate) fn buckets(&self) -> &[Bucket] {
 &self.buckets
 }
}

// 示例 6-3：使用 #[cfg(test)] 使内部状态在测试上下文中可访问
```

### 测试断言的记录

仅在测试期间存在代码的第二个好处是，您可以扩充程序以执行额外的运行时记录，然后可以通过测试进行检查。例如，假设您正在编写标准库中 `BufWriter` 类型的自定义版本。在测试它时，您需要确保 `BufWriter` 不会发出不必要的系统调用。最明显的方法是让 `BufWriter` 跟踪它在底层 `Write` 函数上调用 `write` 的次数。然而，在生产环境中，这些信息并不重要，跟踪这些信息会引入（边际的）性能和内存开销。使用 `#[cfg(test)]`，您可以让记录仅在测试时进行，如清单 6-4 所示。

```rust
struct BufWriter<T> {
 #[cfg(test)]
 write_through: usize,
 // other fields...
}
impl<T: Write> Write for BufWriter<T> {
 fn write(&mut self, buf: &[u8]) -> Result<usize> {
 // ...
 if self.full() {
 #[cfg(test)]
 self.write_through += 1;
 let n = self.inner.write(&self.buffer[..])?;
 // ...
 }
}

// 示例 6-4：使用 #[cfg(test)] 将簿记限制在测试上下文中
```
请记住，测试仅针对正在编译为测试的crate进行设置。对于单元测试，正如您所期望的那样，这是正在测试的crate。但是，对于集成测试，它是正在编译为测试的集成测试二进制文件——您正在测试的包只是作为库编译的，因此不会设置测试集。

## Doctests

文档注释中的 Rust 代码片段会自动作为测试用例运行。这些通常被称为 `doctest`。由于 `doctest` 出现在你的 crate 的公共文档中，并且用户可能会模仿它们包含的内容，因此它们会作为集成测试运行。这意味着 `doctest` 无法访问私有字段和方法，并且测试不会在主 crate 的代码中设置。每个 `doctest` 都会被编译为一个专用的 crate，并独立运行，就像用户将 `doctest` 复制粘贴到自己的程序中一样。编译器会在后台对 `doctest` 进行一些预处理，使其更简洁。最重要的是，它会自动在你的代码周围添加一个 `fn main`。这使得 `doctest` 可以只关注用户可能关心的重要部分，例如实际使用库中类型和方法的部分，而无需包含不必要的样板代码。

您可以通过在文档测试中定义自己的 `fn main` 来避免这种自动包装。例如，如果您想使用类似 `#[tokio::main] async fn main` 的异步 `main` 函数，或者想在文档测试中添加其他模块，您可能需要这样做。
要在文档测试中使用 `?` 运算符，通常无需使用自定义 `main` 函数，因为 `rustdoc` 包含一些启发式方法，可以将返回类型设置为 `Result<(), impl Debug>`。您的代码看起来像是使用了 `?` 运算符（例如，如果它以 `Ok(())` 结尾 。如果类型推断让您难以确定函数的错误类型，您可以通过将文档测试的最后一行更改为显式类型来消除歧义，如下所示：Ok::<(), T>(())。
文档测试具有许多附加功能，在为更复杂的接口编写文档时非常有用。首先是隐藏单行代码的功能。如果在文档测试的某一行前面加上 #，则该行会在文档测试编译和运行时被包含，但不会包含在文档生成的代码片段中。这让您可以轻松隐藏对当前示例不重要的细节，例如为虚拟类型实现特征或生成值。如果您希望呈现一系列示例，而不想每次都显示相同的前导代码，此功能也非常有用。清单 6-5 给出了一个隐藏行的文档测试示例。

```rust
/// Completely frobnifies a number through I/O.
///
/// In this first example we hide the value generation.
/// ```
/// # let unfrobnified_number = 0;
/// # let already_frobnified = 1;
/// assert!(frobnify(unfrobnified_number).is_ok());
/// assert!(frobnify(already_frobnified).is_err());
/// ```
///
/// Here's an example that uses ? on multiple types
/// and thus needs to declare the concrete error type,
/// but we don't want to distract the user with that.
/// We also hide the use that brings the function into scope.
/// ```
/// # use mylib::frobnify;
/// frobnify("0".parse()?)?;
/// # Ok::<(), anyhow::Error>(())
/// ```
///
/// You could even replace an entire block of code completely,
/// though use this _very_ sparingly:
/// ```
/// # /*
/// let i = ...;
/// # */
/// # let i = 42;
/// frobnify(i)?;
/// ```
fn frobnify(i: usize) -> std::io::Result<()> {

// 示例 6-5：使用 # 隐藏文档测试中的行
```
> 请谨慎使用此功能；如果用户复制粘贴示例，然后由于您隐藏了所需步骤而无法使用，这可能会让他们感到沮丧。

与 `#[test]` 函数非常相似，`doctest` 也支持修改 `doctest` 运行方式的属性。这些属性紧跟在用于表示代码块的三个反引号之后，多个属性可以用逗号分隔。与测试函数类似，您可以指定 `should_panic` 属性，指示特定 `doctest` 中的代码在运行时应该崩溃，或者`ignore` 属性仅在使用 `--ignored` 标志运行 `cargo test` 时才检查代码段。您还可以使用 `no_run` 属性，指示给定的 `doctest `应该编译但不应运行。
属性 `compile_fail` 告诉 `rustdoc` 文档示例中的代码不应编译。这向用户表明特定用途不可行，并可作为一个有用的测试，提醒您在库的相关方面发生变化时更新文档。您还可以使用此属性检查某些静态属性是否适用于您的类型。清单 6-6 展示了如何使用 `compile_fail` 来检查给定类型是否未实现 `Send` 的示例，这对于在不安全代码中维护安全保证可能是必要的。

`````rust
 ```compile_fail
# struct MyNonSendType(std::rc::Rc<()>);
fn is_send<T: Send>() {}
is_send::<MyNonSendType>();
 ```

// 示例 6-6：使用 compile_fail 测试代码编译失败
`````
compile_fail 是一个相当粗糙的工具，因为它无法提供任何代码无法编译的原因。例如，如果代码因为缺少分号而无法编译，那么 `compile_fail` 测试看起来会成功。
因此，通常只有在确认测试确实编译失败并出现预期错误后，才需要添加此属性。如果您需要更细粒度的编译错误测试，例如在开发宏时，请查看 `trybuild crate`。















