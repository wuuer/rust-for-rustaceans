# 第十二章 - 没有标准库的Rust

Rust 旨在成为一种系统编程语言，但这究竟意味着什么并不总是清晰的。至少，系统编程语言通常被期望允许程序员编写不依赖于操作系统、可直接在硬件上运行的程序，无论硬件是千核超级计算机，还是配备时钟速度为 72MHz 且内存为 256KiB 的单核 ARM 处理器的嵌入式设备。

&nbsp;&nbsp;&nbsp;&nbsp;在本章中，我们将学习如何在非常规环境中使用 Rust，例如没有操作系统的环境，或者甚至没有动态分配内存能力的环境！我们的大部分讨论将集中在 `#![no_std]` 属性上，但我们也会研究 Rust 的 `alloc` 模块、Rust 运行时（是的，Rust 从技术上来说确实有一个运行时），以及编写用于此类环境的 Rust 二进制文件时需要掌握的一些技巧。

## 选择退出标准库

Rust 作为一种语言，由多个独立的部分组成。首先是编译器，它规定了 Rust 语言的语法，并实现类型检查、借用检查以及最终转换为机器可运行的代码。其次是标准库 `std`，它实现了大多数程序所需的所有常用功能——例如文件和网络访问、时间概念、打印和读取用户输入的功能等等。但 `std` 本身也是一个复合库，它构建于另外两个更基础的库 `core` 和 `alloc` 之上。事实上，`std` 中的许多类型和函数只是从这两个库中重新导出的。

&nbsp;&nbsp;&nbsp;&nbsp;`core`库位于`std`库金字塔的底部，包含所有仅依赖于 Rust 语言本身及其所运行程序的硬件的功能——例如: 排序算法、标记类型、基本类型（例如 Option 和 Result）、低级操作（例如原子内存访问方法）以及编译器提示。`core`库的工作方式如同操作系统不存在一样，因此没有标准输入、没有文件系统、也没有网络。同样，它也没有内存分配器，因此 `Box`、`Vec` 和 `HashMap` 等类型也不存在。

&nbsp;&nbsp;&nbsp;&nbsp;`core`之上是 `alloc`，它包含所有依赖于动态内存分配的功能，例如集合、智能指针和动态分配的字符串 (String)。我们将在下一节中回顾 `alloc`。

&nbsp;&nbsp;&nbsp;&nbsp;大多数情况下，由于 `std` 会重新导出 `core` 和 `alloc` 中的所有内容，因此开发者无需了解这三个库之间的区别。这意味着，即使 `Option` 从技术上讲位于 `core::option::Optio`n 中，您也可以通过 `std::option::Option` 访问它。

&nbsp;&nbsp;&nbsp;&nbsp;然而，在非传统环境中，例如在没有操作系统的嵌入式设备上，这种区别至关重要。虽然使用`Iterator`或对数字`list`进行排序是可以的，但嵌入式设备可能根本没有任何有效的方式来访问文件（因为这需要文件系统）或打印到终端（因为这需要终端）——所以没有 `File` 或 `println!`。此外，设备的内存可能非常小，以至于动态内存分配对您来说是一种负担不起的奢侈，因此任何动态分配内存的方法都是行不通的——跟 `Box` 和 `Vec` 说再见吧。

&nbsp;&nbsp;&nbsp;&nbsp;Rust 并没有强迫开发者在这样的环境中小心翼翼地避免使用这些基本结构，而是提供了一种方法，允许开发者选择退出语言核心功能以外的任何功能：`#![no_std]` 属性。这是一个 `crate` 级别的属性 `(#!)`，它将 `crate` 的 `prelude`（参见 213 页的方框）从 `std::prelude` 切换到 `core::prelude`，这样你就不会意外地依赖核心之外的任何可能在你的目标环境中无法正常工作的功能。

&nbsp;&nbsp;&nbsp;&nbsp;然而，`#![no_std]` 属性的作用仅限于此——它不会阻止你使用 `extern std` 显式引入标准库。这可能令人惊讶，因为这意味着标记为 `#![no_std]` 的 `crate` 实际上可能与不支持 `std` 的目标环境不兼容，但这种设计决策是有意为之的：它允许你将 `crate` 标记为不兼容 `std`，但在启用某些功能时仍然可以使用标准库中的功能。例如，许多 `crate` 都包含一个名为 `std` 的功能，启用后可以访问更复杂的 API 并与 `std` 中的类型集成。这使得 `crate` 作者既可以为受限用例提供核心实现，也可以为更标准平台上的用户添加额外的功能。

> 由于功能应具有附加性，因此优先选择启用 `std` 的功能，而不是禁用 `std` 的功能。否则，如果使用者依赖关系图中的任何一个 `crate` 启用了 `no-std` 功能，则所有使用者将只能访问不支持 `std` 的基本 API，这可能意味着他们所依赖的 API 不可用，从而导致它们无法编译。

> THE PRELUDE
> 你有没有想过，为什么有些类型和特性（例如 `Box`、`Iterator`、`Option` 和 `Clone`）在每个 Rust 文件中都可用，而你无需使用它们？或者为什么你不需要使用标准库中的任何宏（例如 `vec!` `[]`）？原因是每个 Rust 模块都会自动导入 Rust 标准 `prelude`，并使用隐式 `use std::prelude::rust_2021::*`（或其他版本的类似方法），这将把该 `crate` 所选版本的 `prelude` 中的所有导出都纳入作用域。除了这种自动包含之外，`prelude` 模块本身并没有什么特殊之处——它们仅仅是 Rust 开发者期望常用的关键类型、特性和宏的 `pub use` 语句的集合。

## 动态内存分配

正如我们在第一章中讨论过的，一台机器有许多不同的内存区域，每个区域都有不同的用途。静态内存用于存储程序代码和静态变量，堆栈用于存储函数局部变量和函数参数，而堆则用于存储其他所有内存。堆支持在运行时分配大小可变的内存区域，并且这些分配会保留任意长的时间。这使得堆内存用途极其广泛，因此你会发现它无处不在。`Vec`、`String`、`Arc`、`Rc` 以及集合类型都是在堆内存中实现的，这使得它们可以随时间增长和收缩，并且能够从函数中返回，而不会引起借用检查器的抱怨。

&nbsp;&nbsp;&nbsp;&nbsp;在幕后，堆实际上只是一大块连续的内存，由分配器管理。分配器提供了堆中不同分配的假象，确保这些分配不会重叠，并且不再使用的内存区域会被重用。默认情况下，Rust 使用系统分配器，这通常是由标准 C 库指定的。这在大多数情况下都适用，但如有必要，您可以通过 `GlobalAlloc` `trait` 结合 `#[global_allocator]` 属性来覆盖 Rust 将使用的分配器，这需要实现 `alloc` 方法（用于分配新的内存段）和 `dealloc` 方法（用于将过去的分配返回给分配器以供重用）。

&nbsp;&nbsp;&nbsp;&nbsp;在没有操作系统的环境中，标准 C 库通常也不可用，因此标准系统分配器也不可用。因此，`#![no_std]` 也排除了所有依赖动态内存分配的类型。但由于完全可以在没有完整操作系统的情况下实现内存分配器，Rust 允许您通过 `alloc` `crate` 选择只使用 Rust 标准库中需要分配器的部分，而无需使用所有 `std` 类型。`alloc` `crate` 附带标准 Rust 工具链（与 `core` 和 `std` 一样），并且包含大多数您常用的堆分配类型，例如 `Box`、`Arc`、`String`、`Vec` 和 `BTreeMap`。`HashMap` 不在其中，因为它依赖于随机数生成进行键哈希计算，而随机数生成是操作系统提供的一项功能。要在 `no_std` 上下文中使用 `alloc` 中的类型，您只需将之前使用 `use std::` 的导入替换为 `use alloc::`。但请记住，依赖 `alloc` 意味着您的 `#![no_std]`
`crate` 将不再适用于任何不允许动态内存分配的程序，无论是因为它没有分配器，还是因为它的内存太少，根本无法允许动态内存分配。

&nbsp;&nbsp;&nbsp;&nbsp;某些编程领域，例如 Linux 内核，可能仅在内存不足错误得到妥善处理（即不引发panics）的情况下才允许动态内存分配。对于此类用例，您需要为公开的任何可能分配内存的方法提供 `try_` 版本。`try_` 方法应该使用任何内部类型的可错方法（例如当前不稳定的 `Box::try_new` 或 `Vec::try_reserve`），而不是那些只会引发panics的方法（例如 `Box::new` 或 `Vec::reserve`），并将这些错误传播给调用者，以便后者能够妥善处理这些错误。

&nbsp;&nbsp;&nbsp;&nbsp;你可能会觉得奇怪，居然可以编写出仅使用`core`的复杂 `crate`。毕竟，它们不能使用集合、`String` 类型、网络或文件系统，甚至没有时间概念！编写仅使用`core`的 `crate` 的诀窍在于利用堆栈和静态分配。例如，对于一个无堆向量，你需要预先分配足够的内存（无论是在静态内存中还是在函数的堆栈框架中），用于存放你期望向量能够容纳的最大元素数量，然后用一个 `usize` 变量来扩充它，该变量跟踪向量当前容纳的元素数量。要将数据推送到向量，你需要写入（静态大小的）数组中的下一个元素，并增加一个跟踪元素数量的变量。如果向量的长度达到静态大小，则下一次推送操作将失败。示例 12-1 给出了一个使用 `const` 泛型实现的无堆向量类型的示例。

```rust
struct ArrayVec<T, const N: usize> {
 values: [Option<T>; N],
 len: usize,
}
impl<T, const N: usize> ArrayVec<T, N> {
 fn try_push(&mut self, t: T) -> Result<(), T> {
 if self.len == N {
 return Err(t);
 }
 self.values[self.len] = Some(t);
 self.len += 1;
 return Ok(());
 }
}


// 示例 12-1：无堆向量类型 
```

&nbsp;&nbsp;&nbsp;&nbsp;我们使 `ArrayVec` 在其元素类型 T 和最大元素数量 N 上都具有泛型性，然后将该向量表示为一个包含 N 个可选 T 类型的数组。该结构始终存储 N 个 `Option<T>`，因此它在编译时具有已知的大小，并且可以存储在堆栈中，但它仍然可以像向量一样工作，通过使用运行时信息来告知我们如何访问该数组。

> 我们可以使用 `[MaybeUninit<T>; N]` 来实现 `ArrayVec`，以避免 `Option` 的开销，但这需要使用不安全的代码，而对于本例来说，这是没有必要的。

## Rust 运行时

你可能听说过 Rust 没有运行时 (runtime) 的说法。虽然从高层次上来说确实如此——它没有垃圾收集器、解释器或内置的用户级调度程序——但严格来说，这并非事实。具体来说，Rust 确实有一些特殊的代码，它们在主函数之前运行，并响应代码中的某些特殊条件，这实际上是一种基本的运行时。

### panic处理程序

这种特殊代码的第一部分是 Rust 的panic处理程序。当 Rust 代码通过调用 `panic!` 或 `panic_any` 导致恐慌时，panic处理程序会指示接下来发生什么。当 Rust 运行时可用时（大多数提供 `std` 的目标系统都是如此），panic处理程序首先会调用通过 `std::panic::set_hook` 设置的panic钩子，默认情况下，它会打印一条消息，并可选地将回溯打印到标准错误。然后，它会展开当前线程的堆栈或中止进程，具体取决于当前编译时选择的panic设置（通过 `Cargo` 配置或直接传递给 `rustc` 的参数）。

&nbsp;&nbsp;&nbsp;&nbsp;然而，并非所有目标都提供panic处理程序。例如，大多数嵌入式目标都没有，因为对于此类目标的所有用途，并不一定存在一个合理的实现。对于不提供panic处理程序的目标，Rust 仍然需要知道在panic发生时该做什么。为此，我们可以使用 `#[panic_handler`] 属性来修饰程序中的单个函数，其签名为 `fn(&PanicInfo) -> !`。每当程序引发panic时，都会调用该函数，并以 `core::panic::PanicInfo` 的形式传递panic信息。该函数如何处理这些信息完全未指定，但它永远不会返回（如 `!` 返回类型所示）。这一点很重要，因为 Rust 编译器假定panic之后的代码不会运行。

&nbsp;&nbsp;&nbsp;&nbsp;panic处理程序有很多有效的方法来避免返回。标准panic处理程序会展开线程的堆栈，然后终止线程，但panic处理程序也可以使用 `loop {}` 暂停线程、中止程序，或者执行任何对目标平台有意义的操作，甚至重置设备。

### 程序初始化

与普遍的看法相反，Rust 程序中首先运行的并非 main 函数。相反，Rust 二进制文件中的 main 符号实际上指向标准库中一个名为 `lang_start` 的函数。该函数执行 Rust 运行时的（相当精简的）设置，包括将程序的命令行参数存储在 `std::env::args` 可以访问的位置、设置主线程的名称、处理 `main` 函数中的panic、在程序退出时刷新标准输出以及设置信号处理程序。`lang_start` 函数反过来会调用 `crate` 中定义的 `main` 函数，这样 `crate` 就无需考虑诸如 Windows 和 Linux 在命令行参数传入方式上的差异等问题。这种安排在所有这些设置都合理且受支持的平台上运行良好，但在嵌入式平台上则存在问题，因为程序启动时甚至可能无法访问主内存。在这样的平台上，你通常需要使用 `#![no_main]` crate级别的属性来完全退出 Rust 初始化代码。此属性完全省略了 `lang_start`，这意味着作为开发者，你必须弄清楚程序应该如何启动，例如，使用 `#[export_name = "main"]` 声明一个与目标平台预期启动顺序匹配的函数。

> 在跳转到定义的起始符号之前真正不运行任何代码的平台上（例如大多数嵌入式设备），静态变量的初始值甚至可能与源代码中指定的值不匹配。在这种情况下，初始化函数需要使用程序二进制文件中指定的初始数据值显式初始化各个静态内存段。

### 内存不足处理程序

如果你编写了一个希望使用 `alloc` 的程序，但它是为一个不提供分配器的平台构建的，则必须使用本章前面提到的 `#[global_allocator]` 属性来指定要使用的分配器。但你还必须指定如果该全局分配器分配内存失败时会发生什么。具体来说，你需要定义一个内存不足处理程序，来说明如果像 `Vec::push` 这样的可靠操作需要分配更多内存，但分配器无法提供时应该发生的情况。

&nbsp;&nbsp;&nbsp;&nbsp;在启用标准错误的平台上，内存不足处理程序的默认行为是将错误消息打印到标准错误输出，然后中止进程。但是，在没有标准错误输出的平台上，这显然行不通。在撰写本文时，在此类平台上，您的程序必须使用不稳定属性 `#[lang = "oom"]` 显式定义内存不足处理程序。请记住，该处理程序应该几乎肯定会阻止将来的执行，否则，尝试分配内存的代码将继续执行，而不知道它没有收到它所请求的内存！

> 当您读到这篇文章时，内存不足处理程序可能已经以永久名称（很可能是 `#[alloc_error_handler]`）稳定下来。此外，我们还在努力为默认的 `std` 内存不足处理程序提供与 Rust 的panic处理程序相同的“钩子”功能，以便代码可以通过类似 `set_alloc_error_hook` 的方法动态更改内存不足行为。

## 低级内存访问

在第 10 章中，我们讨论了编译器在将程序语句转换为机器指令时拥有相当大的灵活性，而 CPU 也拥有一定的灵活性来执行乱序指令。通常情况下，编译器和 CPU 可以利用的快捷方式和优化对程序的语义是不可见的——例如，你通常无法判断两次读取是否被重新排序，或者两次从同一内存位置的读取是否实际上导致了两条 CPU 加载指令。这是设计使然。语言和硬件设计者仔细地指定了程序员通常期望代码在运行时具有的语义，以便你的代码通常能够按照你的期望运行。

&nbsp;&nbsp;&nbsp;&nbsp;然而，`no_std` 编程有时会让你超越通常的“隐形优化”的界限。具体来说，你经常会通过内存映射与硬件设备通信，此时设备的内部状态会在精心选择的内存区域中提供。例如，当你的计算机启动时，内存地址范围 0xA0000–0xBFFFF 会映射到一个粗糙的图形渲染管线；写入该范围内的单个字节将会改变屏幕上的特定像素（或块，取决于模式）。

&nbsp;&nbsp;&nbsp;&nbsp;当您与设备映射内存交互时，设备可能会为每次访问该内存区域实现自定义行为，因此 CPU 和编译器对常规内存加载和存储的假设可能不再成立。例如，硬件设备通常具有内存映射寄存器，这些寄存器在读取时会被修改，这意味着读取操作会产生副作用。在这种情况下，如果您连续两次读取相同的内存地址，编译器将无法安全地省略内存存储操作！

&nbsp;&nbsp;&nbsp;&nbsp;当程序执行突然以代码中未体现的方式发生转移时，也会出现类似的问题，编译器也无法预料。如果没有底层操作系统来处理处理器异常或中断，或者进程接收到中断执行的信号，执行可能会发生转移。在这些情况下，活动代码段的执行将停止，CPU 开始执行触发转移事件的事件处理程序中的指令。通常情况下，由于编译器可以预测所有可能的执行，因此它会进行优化，使执行无法观察到操作何时乱序执行或被优化。然而，由于编译器无法预测这些异常跳转，它也无法计划让它们忽略其优化，因此这些事件处理程序实际上可能会观察到与原始程序代码中运行顺序不同的指令。

&nbsp;&nbsp;&nbsp;&nbsp;为了应对这些异常情况，Rust 提供了易失性内存操作，这些操作相对于其他易失性操作而言不能被省略或重新排序。这些操作的形式为 `std::ptr::read_volatile` 和 `std::ptr::write_volatile`。易失性操作非常适合访问内存映射的硬件资源：它们直接映射到内存访问操作，无需任何编译器技巧；并且易失性操作之间不会重新排序的保证，确保了可能产生副作用的硬件操作不会乱序执行，即使它们通常看起来可以互换（例如，加载一个地址并存储到另一个地址）。只要任何在异常上下文中访问内存的代码只使用易失性内存操作，这种不重新排序的保证也有助于处理异常执行情况。

> 还有一个 `std::sync::atomic::compiler_fence` 函数，可以防止编译器对非易失性内存访问进行重新排序。你很少需要编译器栅栏，但它的文档值得一读。
> 包括汇编代码
>
> 如今，你很少需要编写汇编代码来完成任何给定的任务。但对于需要在启动时初始化 CPU 或发出奇怪的指令来操作内存映射的底层硬件编程来说，有时仍然需要汇编代码。在撰写本文时，Rust Nightly 版本中已经有一个 RFC 和一个基本完整的内联汇编语法实现，但尚未稳定下来，因此本书中不会讨论该语法。
>
> &nbsp;&nbsp;&nbsp;&nbsp;在稳定的 Rust 上编写汇编代码仍然是可能的——你只需要发挥一点创造力。具体来说，还记得第十一章的构建脚本吗？`Cargo` 构建脚本可以向标准输出发出某些特殊指令，以增强 `Cargo` 的标准构建流程，例如 `cargo:rustc-link-lib=static=xyz`用于将静态库文件 `libxyz.a` 链接到最终的二进制文件中，以及 `cargo:rustc-linksearch:/some/path`用于将 `/some/path` 添加到链接对象的搜索路径中。使用这些指令，我们可以在项目中添加一个 `build.rs` 文件，该文件使用目标平台的编译器将独立的汇编文件 (`.s`) 编译为目标文件 (`.o`)，然后使用合适的归档工具（通常是 `ar`）将其重新打包成静态归档文件 (`.a`)。然后，项目会发出这两个 `Cargo` 指令，指向静态归档文件的存放位置——可能是 `OUT_DIR` 目录——然后我们就可以开始啦！如果目标平台没有改变，您甚至可以在发布您的板条箱时包含预编译的`.a`，这样消费者就不需要重建它。

## 防滥用硬件抽象

Rust 的类型系统擅长将不安全、复杂以及其他令人不快的代码封装在安全、符合人体工程学的接口背后。这一点在以复杂著称的底层系统编程领域中尤为重要，因为在这个领域中，充斥着从晦涩手册中提取的、由硬件定义的魔法值，以及神秘的、未记录的汇编指令，这些指令只是为了让设备进入正确的状态。而这一切都发生在一个运行时错误可能比用户程序崩溃更严重的环境中！

&nbsp;&nbsp;&nbsp;&nbsp;在 `no_std` 程序中，使用类型系统使非法状态无法表示至关重要，正如我们在第 3 章中讨论的那样。如果某些寄存器值的组合不能同时出现，则创建一个单一类型，其类型参数指示相关寄存器的当前状态，并且仅在其上实现合法的转换，就像我们在清单 3-2 中的火箭示例中所做的那样。

> 请务必查看第三章关于 API 设计的建议——所有这些建议也适用于 `no_std` 程序！

&nbsp;&nbsp;&nbsp;&nbsp;例如，考虑一对寄存器，其中最多只有一个寄存器在任何给定时间点应该处于“开启”状态。清单 12-2 展示了如何在（单线程）程序中表示这一点，使得编写违反该不变量的代码成为不可能。

```rust
// raw register address -- private submodule
mod registers;
pub struct On;
pub struct Off;
pub struct Pair<R1, R2>(PhantomData<(R1, R2)>);
impl Pair<Off, Off> {
    pub fn get() -> Option<Self> {
        static mut PAIR_TAKEN: bool = false;
        if unsafe { PAIR_TAKEN } {
            None
        } else {
            // Ensure initial state is correct.
            registers::off("r1");
            registers::off("r2");
            unsafe { PAIR_TAKEN = true };
            Some(Pair(PhantomData))
        }
    }
    pub fn first_on(self) -> Pair<On, Off> {
        registers::set_on("r1");
        Pair(PhantomData)
    }
    // .. and inverse for -> Pair<Off, On>
}
impl Pair<On, Off> {
    pub fn off(self) -> Pair<Off, Off> {
        registers::set_off("r1");
        Pair(PhantomData)
    }
}
// .. and inverse for Pair<Off, On>

// 清单 12-2：静态确保正确操作
```

&nbsp;&nbsp;&nbsp;&nbsp;这段代码中有几个值得注意的模式。首先，我们通过检查其唯一构造函数中的私有静态布尔值，并确保所有方法都使用 `self`，来确保 `Pair` 始终只有一个实例存在。然后，我们确保初始状态有效，并且只能表达有效的状态转换，因此不变量必须全局成立。

&nbsp;&nbsp;&nbsp;&nbsp;示例 12-2 中第二个值得注意的模式是，我们使用 `PhantomData` 来利用零大小类型，并静态地表示运行时信息。也就是说，在代码中的任何给定点，类型都会告诉我们运行时状态必须是什么，因此我们无需在运行时跟踪或检查任何与寄存器相关的状态。当我们被要求启用 `r1` 时，无需检查 `r2` 是否已打开，因为这些类型阻止我们编写需要启用寄存器 `r1` 的程序。

## 交叉编译

通常，你会在一台运行着成熟操作系统并具备所有现代硬件特性的计算机上编写 `no_std` 程序，但最终它会在一个只有 9.75 位 RAM 和一个 CPU 插槽的小型硬件设备上运行。这就需要交叉编译——你需要在开发环境中编译代码，但要针对 CPU 进行编译。不过，这并非交叉编译唯一重要的应用场景。例如，越来越常见的做法是使用一个构建流水线为所有消费平台生成二进制文件，而不是尝试为每个消费者可能使用的平台都创建一个构建流水线，这意味着需要使用交叉编译。

> 如果你实际上正在编译类似袜子且内存有限的程序，或者像土豆这样奇特的程序，你可能需要将 `opt-level` `Cargo` 配置设置为“s”，以优化更小的二进制文件大小。

&nbsp;&nbsp;&nbsp;&nbsp;交叉编译涉及两个平台：主机平台和目标平台。主机平台执行编译，而目标平台最终运行编译输出。我们将平台指定为目标三元组，其形式为 `machine-vendor-os`。`machine` 部分指示代码将在其上运行的机器架构，例如 `x86_64`、`armv7` 或 `wasm32`，并告知编译器要使用哪种指令集来生成机器代码。`vendor` 部分通常在 `Windows` 上取 `pc` 值，在 `macOS` 和 `iOS` 上取 `apple` 值，在其他地方取 `unknown` 值，并且不会以任何有意义的方式影响编译；它几乎无关紧要，甚至可以省略。os 部分指示编译器要使用哪种格式来生成最终的二进制文件，因此，linux 值指示 Linux 的 `.so` 文件，`windows` 指 `Windows` 的 `.dll` 文件，等等。

> 默认情况下，`Cargo` 会假定目标平台与主机平台相同，因此，如果您已经在使用 Linux，通常无需告诉 `Cargo` 进行 Linux 编译。但有时，即使目标平台的 CPU 和操作系统相同，您也可能希望使用 `--target` 选项，例如，以 `libc` 的 `musl` 实现为目标。

&nbsp;&nbsp;&nbsp;&nbsp;要告诉 `Cargo` 进行交叉编译，只需将 `--target <target triple>` 参数传递给它，并指定您选择的三元组即可。`Cargo` 会负责将这些信息转发给 Rust 编译器，以便生成可在给定目标平台上运行的二进制文件。`Cargo` 还会负责使用适用于该平台的标准库版本——毕竟，标准库包含许多条件编译指令（`使用 #[cfg(...)]`），以便调用正确的系统调用并使用正确的架构特定实现，因此我们不能在目标平台上使用主机平台的标准库。

&nbsp;&nbsp;&nbsp;&nbsp;目标平台还规定了标准库中哪些组件可用。例如，虽然 `x86_64-unknown-linux-gnu` 包含完整的 `std` 库，但类似 `thumbv7m-none-eabi` 的库却不包含，甚至没有定义`alloc`分配器。因此，如果您使用 `alloc` 而没有明确定义，就会出现构建错误。这对于测试您编写的代码是否真的不需要 `std` 非常有用（记住，即使使用 `#![no_std]`，您仍然可以使用 `std::`，因为 `no_std` 只会选择不使用 `std` 前置函数）。如果您的持续集成流水线使用 `--target thumbv7m-none-eabi` 构建您的 `crate`，任何尝试访问核心库以外的组件都将触发构建失败。至关重要的是，这还会检查您的 `crate` 是否意外引入了本身使用 `std`（或 `alloc`）中项目的依赖项。

> 平台支持
>
> Rust 的标准安装程序 `Rustup` 不会默认安装 Rust 支持的所有目标三元组的标准库。这会浪费空间和带宽。因此，您必须使用命令 `rustup target add` 来为其他目标安装相应的标准库版本。如果您的目标平台没有相应的标准库版本，则需要自行从源代码编译，方法是添加 `rust-src Rustup` 组件，并使用 `Cargo` 的（目前不稳定的）`build-std` 功能在构建任何 `crate` 时也构建 `std`（和/或 `core` 和 `alloc`）。
>
> &nbsp;&nbsp;&nbsp;&nbsp;如果您的目标不受 Rust 编译器支持——也就是说，如果 `rustc` 甚至不知道您的目标三元组——那么您必须更进一步，使用自定义目标规范将三元组的属性传授给 `rustc`。如何做到这一点目前还不稳定，也超出了本书的讨论范围，但搜索“自定义目标规范 json”是一个不错的起点。

## 总结

在本章中，我们介绍了标准库底层的内容——或者更准确地说，`std` 底层的内容。我们讨论了 `core` 的功能，如何使用 `alloc` 扩展非标准库的访问范围，以及 Rust 运行时（微型）为使 `fn main` 正常工作而添加到程序中的功能。我们还探讨了如何与设备映射内存交互，以及如何处理在硬件编程的最底层可能发生的非常规执行模式，以及如何在 Rust 类型系统中安全地封装至少一些硬件的奇特之处。接下来，我们将从小处着手，逐步深入，讨论如何导航、理解甚至为更广阔的 Rust 生态系统做出贡献。
