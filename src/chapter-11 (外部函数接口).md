# 第十一章 外部函数接口

并非所有代码都是用 Rust 编写的。我知道这很令人震惊。有时，您需要与其他语言编写的代码进行交互，要么从 Rust 调用这些代码，要么允许这些代码调用您的 Rust 代码。您可以通过外部函数接口 (`FFI`) 来实现。在本章中，我们将首先了解 Rust 为 `FFI` 提供的主要机制：`extern` 关键字。我们将了解如何使用 `extern` 将 Rust 函数和静态变量暴露给其他语言，以及如何让 Rust 访问 Rust 外部提供的函数和静态变量。然后，我们将逐步讲解如何将 Rust 类型与其他语言定义的类型对齐，并探讨允许数据跨越 FFI 边界的一些复杂细节。最后，我们将讨论一些在进行大量 FFI 操作时可能需要使用的工具。

> 虽然我经常将 FFI 描述为跨越不同语言之间的界限，但 FFI 也可以完全在 Rust 领域内发生。如果一个 Rust 程序与另一个 Rust 程序共享内存，但这两个程序并非一起编译——比如，如果你在 Rust 程序中使用了一个动态链接库，而该库恰好是用 Rust 编写的，但你只有兼容 C 语言的 `.so` 文件——同样的复杂情况也会出现。

## 与外部跨越界限

最终，FFI 的核心在于访问源自应用程序 Rust 代码外部某个位置的字节。为此，Rust 提供了两个主要构建块：符号，即分配给二进制文件给定段中特定地址的名称，用于在外部源和 Rust 代码之间共享内存（无论是用于数据还是代码）；调用约定，用于就如何调用存储在此类共享内存中的函数提供统一的理解。我们将依次介绍这两个约定。

### 符号

编译器根据你的代码生成的任何二进制文件都充满了符号——你定义的每个函数或静态变量都有一个符号，指向它在编译后的二进制文件中的位置。泛型函数甚至可能拥有多个符号，每个符号对应编译器生成的函数的每个单态化！

&nbsp;&nbsp;&nbsp;&nbsp;通常情况下，您无需考虑符号——它们由编译器内部使用，用于传递二进制文件中函数或静态变量的最终地址。编译器正是通过这种方式，知道每次函数调用在生成最终机器码时应该指向内存中的哪个位置，或者在代码访问静态变量时应该从哪里读取。由于您通常不会在代码中直接引用符号，因此编译器默认会为它们选择半随机名称——您可能在代码的不同部分有两个名为 `foo` 的函数，但编译器会根据它们生成不同的符号，以免造成混淆。

&nbsp;&nbsp;&nbsp;&nbsp;但是，当您想要调用一个函数或访问一个未同时编译的静态变量时，例如用不同语言编写的代码，并因此由不同的编译器编译，则使用随机符号名称将无法正常工作。如果一个静态变量的符号名称是不断变化的半随机名称，则您无法将 C 语言中定义的静态变量告知 Rust。相反，如果您无法为 Rust 函数生成一个稳定的名称，则您无法将 Rust 函数的相关信息告知 Python 的 `FFI` 接口。

&nbsp;&nbsp;&nbsp;&nbsp;要使用外部来源的符号，我们还需要某种方式告知 Rust 某个变量或函数，以便编译器查找在其他地方定义的相同符号，而不是自己定义的符号（我们稍后会讨论如何进行搜索）。否则，我们最终会得到该函数或静态变量的两个相同符号，并且不会发生共享。事实上，编译很可能会失败，因为任何引用该符号的代码都不知道该使用哪个定义（即哪个地址）来引用它！

> 关于术语的简要说明：一个符号可以声明多次，但只能定义一次。在链接时，每个符号的声明都会链接到该符号的同一个定义。如果找不到某个声明的定义，或者存在多个定义，链接器就会报错。

#### 关于编译和链接的补充

编译器速成课时间到！大致了解将代码转换为可运行二进制文件的复杂过程将有助于您更好地理解 `FFI`。您会发现，编译器并非一个庞大的程序，而是（通常）分解成几个较小的程序，每个程序执行不同的任务并依次运行。从高层次上讲，编译分为三个不同的阶段——编译、代码生成和链接——由三个不同的组件处理。

&nbsp;&nbsp;&nbsp;&nbsp;第一阶段由大多数人认为的“编译器”执行；它处理类型检查、借用检查、单态化以及我们与特定编程语言相关的其他功能。此阶段不会生成机器码，而是生成代码的低级表示，其中使用了大量注释的抽象机器操作。然后，该低级表示被传递给代码生成工具，该工具生成可在给定CPU上实际运行的机器码。

&nbsp;&nbsp;&nbsp;&nbsp;这两个操作合在一起，不必一次性在整个代码库中运行。相反，代码库可以被切分成更小的块，然后并发编译。例如，Rust 通常会独立地并行编译不同的 `crate`，只要它们之间没有依赖关系。它还可以分别调用独立 `crate` 的代码生成工具来并行处理它们。Rust 通常甚至可以单独编译单个 `crate` 的多个小片段！

&nbsp;&nbsp;&nbsp;&nbsp;一旦生成了应用程序各个部分的机器码，就可以将这些部分连接在一起。这在链接阶段由链接器完成，这一点毋庸置疑。链接器的主要工作是获取代码生成生成的所有二进制文件（称为目标文件），将它们拼接成一个文件，然后将对每个符号的引用替换为该符号的最终内存地址。这样，您就可以在一个包中定义一个函数，并在另一个包中调用它，但仍然可以分别编译这两个包。

&nbsp;&nbsp;&nbsp;&nbsp;链接器是 `FFI` 工作的基础。它不关心每个输入目标文件的构造方式；它只是忠实地将所有目标文件链接在一起，然后解析任何共享符号。一个目标文件可能最初是 Rust 代码，一个最初是 C 代码，还有一个可能是从互联网下载的二进制 `blob`；只要它们都使用相同的符号名，链接器就会确保生成的机器码对任何共享符号使用正确的交叉引用地址。

&nbsp;&nbsp;&nbsp;&nbsp;符号可以静态链接，也可以动态链接。静态链接是最简单的，因为对符号的每个引用都只需替换为该符号定义的地址即可。另一方面，动态链接将对符号的每个引用与一段生成的代码绑定在一起，该代码会在程序运行时尝试查找符号的定义。我们稍后会详细讨论这些链接模式。Rust 通常默认对 Rust 代码使用静态链接，对 `FFI` 代码使用动态链接。

#### 使用 extern

`extern` 关键字是一种机制，它允许我们将一个符号声明为位于外部接口中。具体来说，它声明了一个在其他地方定义的符号的存在。在示例 11-1 中，我们在 Rust 中定义了一个名为 `RS_DEBUG` 的静态变量，并通过 `FFI` 将其提供给其他代码。我们还声明了一个名为 `FOREIGN_DEBUG` 的静态变量，其定义未指定，但会在链接时解析。

```rust
#[no_mangle]
pub static RS_DEBUG: bool = true;
extern {
 static FOREIGN_DEBUG: bool;
}

// 示例 11-1：通过 FFI 暴露 Rust 静态变量并访问在其他地方声明的变量
```

&nbsp;&nbsp;&nbsp;&nbsp;`#[no_mangle]` 属性确保 `RS_DEBUG` 在编译期间保留该名称，而不是让编译器为其分配另一个符号名，例如，为了将其与程序中其他位置的另一个（非 `FFI`）RS_DEBUG 静态变量区分开来。该变量也被声明为 `pub`，因为它是 `crate` 公共 API 的一部分，尽管对于标记为 `#[no_mangle]` 的项目，该注解并非严格必需。请注意，我们没有对 `RS_DEBUG` 使用 `extern`，因为它在此处定义。它仍然可以从其他语言链接访问。

&nbsp;&nbsp;&nbsp;&nbsp;围绕 `FOREIGN_DEBUG` 静态变量的 `extern` 代码块表示，此声明指向一个 Rust 将在链接时根据相同符号的定义位置进行识别的位置。由于它在其他地方定义，因此我们不会赋予它初始化值，而只会赋予它一个类型，该类型应该与定义处使用的类型匹配。由于 Rust 对定义该静态变量的代码一无所知，因此无法检查你是否为该符号声明了正确的类型，因此，`FOREIGN_DEBUG` 只能在不安全代码块内访问。

> Rust 中的静态变量默认不可变，无论它们是否位于 `extern` 块中。这些变量在任何线程中始终可用，因此可变访问会带来数据竞争风险。您可以将静态变量声明为 `mut`，但这样做会造成访问不安全。

&nbsp;&nbsp;&nbsp;&nbsp;声明 `FFI` 函数的过程非常相似。在示例 11-2 中，我们让 `hello_rust` 可以被非 Rust 代码访问，并引入外部的`hello_foreign` 函数。

```rust
#[no_mangle]
pub extern fn hello_rust(i: i32) { ... }
extern {
 fn hello_foreign(i: i32);
}

// 示例 11-2：通过 FFI 暴露 Rust 函数并访问其他地方定义的函数
```

&nbsp;&nbsp;&nbsp;&nbsp;除了 Rust 函数是使用 `extern fn` 声明的之外，其余构建块与示例 11-1 中的相同，我们将在下一节中探讨这一点。

&nbsp;&nbsp;&nbsp;&nbsp;如果给定的外部符号（例如 `FOREIGN_DEBUG` 或 `hello_foreign`）有多个定义，您可以使用 `#[link]` 属性明确指定该符号应该链接到哪个库。如果不指定，链接器将返回错误，提示您发现了该符号的多个定义。例如，如果您在外部代码块前添加 `#[link(name = "crypto")]`，则表示链接器将任何符号（无论是静态变量还是函数）解析为名为“crypto”的链接库。您还可以在 Rust 代码中重命名外部静态变量或函数，方法是在其声明中添加 `#[link_name = "<actual_symbol_name>"]` 注释，然后该项将链接到您希望的任何名称。同样，您可以使用 `#[export_name = "<export_symbol_name>"` 重命名要导出的 Rust 项。

#### 链接种类

`#[link]` 还接受参数 `kind`，该参数指定块中的项应如何链接。该参数默认为“dylib”，表示与 C 兼容的动态链接。另一个 `kind` 值为“static”，表示块中的项应在编译时完全链接（即静态链接）。这实际上意味着外部代码直接连接到编译器生成的二进制文件中，因此无需在运行时存在。此外，还有其他一些类型，但它们不太常见，也超出了本书的讨论范围。

&nbsp;&nbsp;&nbsp;&nbsp;静态链接和动态链接之间存在一些权衡，但主要考虑因素是安全性、二进制文件大小和分发。首先，动态链接往往更安全，因为它更容易独立升级库。动态链接允许部署包含您代码的二进制文件的人升级您代码所链接的库，而无需重新编译您的代码。例如，如果 `libcrypto` 获得安全更新，用户可以在主机上更新加密库并重新启动二进制文件，更新后的库代码将自动使用。使用静态编译时，库的代码被硬编码到二进制文件中，因此用户必须根据库的升级版本重新编译您的代码才能获得更新。

&nbsp;&nbsp;&nbsp;&nbsp;动态链接也倾向于生成更小的二进制文件。由于静态编译会将所有链接的代码都包含到最终的二进制输出中，并且会将链接的代码导入到最终的二进制输出中，因此它会生成更大的二进制文件。使用动态链接时，每个外部项只包含一小段包装器代码，这些代码会在运行时加载指定的库，然后转发访问。

&nbsp;&nbsp;&nbsp;&nbsp;到目前为止，静态链接可能看起来不太吸引人，但它比动态链接有一个很大的优势：易于分发。使用动态链接，任何想要运行包含你代码的二进制文件的人都必须拥有你的代码所链接的任何库。不仅如此，他们还必须确保他们拥有的每个此类库的版本都与你的代码所期望的兼容。对于大多数系统上可用的库（例如 `glibc` 或 `OpenSSL`）来说，这可能没问题，但对于一些不太常用的库来说，这就成问题了。用户需要注意他们应该安装该库，并且必须搜索它才能运行你的代码！使用静态链接，库的代码直接嵌入到二进制输出中，因此用户无需自行安装。

&nbsp;&nbsp;&nbsp;&nbsp;归根结底，静态链接和动态链接之间并没有绝对的正确选择。动态链接通常是一个不错的默认设置，但对于特别受限的部署环境，或者对于非常小或特定的库依赖项，静态编译可能是一个更好的选择。请自行判断！

### 调用约定

符号指示了给定函数或变量的定义位置，但这不足以允许跨 `FFI` 边界进行函数调用。要使用任何语言调用外部函数，编译器还需要知道其调用约定，这决定了调用该函数所需的汇编代码。我们不会在这里深入探讨每个调用约定的实际技术细节，但作为概述，该约定规定：

• 如何设置调用堆栈框架
• 如何传递参数（无论是在堆栈中还是在寄存器中，按顺序还是反向传递）
• 如何告知函数返回时跳转到何处
• 函数完成后，如何在调用者中恢复各种 CPU 状态（例如寄存器）

&nbsp;&nbsp;&nbsp;&nbsp;Rust 有其独特的调用约定，它并非标准化的，并且允许编译器随时间推移进行更改。只要所有函数定义和调用都由同一个 Rust 编译器编译，这种约定就没问题。但如果你想要与外部代码互操作，就会出现问题，因为外部代码并不知道 Rust 的调用约定。

&nbsp;&nbsp;&nbsp;&nbsp;如果没有声明任何其他内容，每个 Rust 函数都会隐式地使用 `extern "Rust"` 声明。像示例 11-2 中那样单独使用 `extern` 是 `extern "C"` 的简写，意思是“使用标准 C 调用约定”。

> 展开通常仅适用于常规 Rust 函数。如果展开到非 `extern "Rust"` 类型的 Rust 函数的末尾，程序将会中止。跨越 FFI 边界展开到外部代码是未定义的行为。在 RFC 2945 中，Rust 增加了一个新的 `extern` 声明，即 `extern "C-unwind"`；这允许在特定情况下跨越 FFI 边界展开，但如果您想使用它，则应该仔细阅读 RFC。

&nbsp;&nbsp;&nbsp;&nbsp;Rust 还支持许多其他调用约定，这些约定可以在 `extern` 关键字后以字符串形式提供（在 fn 和块上下文中）。例如，`extern "system"` 表示使用操作系统标准库接口的调用约定，在撰写本文时，除了 `Win32` 中使用“stdcall”调用约定外，其他所有语言的调用约定都与“C”相同。通常，除非您使用特定平台或高度优化的外部接口，否则很少需要显式提供调用约定，因此只需使用 `extern`（即 `extern "C"`）即可。

> 函数的调用约定是其类型的一部分。也就是说，`extern "C" fn()` 的类型与 `fn()`（或 `extern "Rust" fn()`）不同，后者又与` extern "system" fn()` 不同。
>
>  其他二进制制品
>
> 通常，你编译 Rust 代码只是为了运行测试或构建二进制文件，然后分发或运行。与许多其他语言不同，你通常不会编译 Rust 库来分发给其他人——如果你运行类似 cargo publish 的命令，它只会打包你的 `crate` 源代码并将其上传到 `crates.io`。这主要是因为除了源代码之外，泛型代码很难以任何其他形式分发。由于编译器将每个泛型函数单态化为提供的类型参数，而这些类型可能在调用者的 `crate` 中定义，因此编译器必须能够访问函数的泛型形式，这意味着没有优化的机器码！
> &nbsp;&nbsp;&nbsp;&nbsp;从技术上讲，Rust 确实会编译最终组合的每个依赖项的二进制库制品（称为 `rlib`）。这些 `rlib` 包含解析泛型所需的信息，但它们特定于所使用的编译器，并且通常无法以任何有意义的方式分发。
> 
> &nbsp;&nbsp;&nbsp;&nbsp;那么，如果你想用 Rust 编写一个库，然后想与其他编程语言交互，你该怎么做呢？解决方案是生成与 C 兼容的库文件，形式包括动态链接库（Unix 上为 `.so` 文件，macOS 上为 `.dylib` 文件，Windows 上为 `.dll` 文件）和静态链接库（Unix/macOS 上为 `.a` 文件，Windows 上为 `.lib` 文件）。这些文件看起来像 C 代码生成的文件，因此其他知道如何与 C 交互的语言也可以使用它们。
> 
> &nbsp;&nbsp;&nbsp;&nbsp;要生成这些与 C 兼容的二进制文件，您需要设置 `Cargo.toml` 文件中 `[lib]` 部分的 `crate-type` 字段。该字段接受一个值数组，通常为“lib”，表示这是一个标准 Rust 库（`rlib`）。如果您的 `crate` 显然不是库（例如，它是一个过程宏），Cargo 会应用一些启发式算法，自动设置此值。但最佳做法是，如果您生成的不是 `Rust` 库，则应明确设置此值。
>
> &nbsp;&nbsp;&nbsp;&nbsp;有许多不同的 `crate` 类型，但这里相关的是“cdylib”和“staticlib”，它们分别生成动态和静态链接的 C 兼容库文件。请记住，当您生成其中一种构件类型时，只有公开可用的符号可用——即`public`和 `#[no_mangle]` 静态变量和函数。诸如类型和常量之类的内容即使标记为 pub 也将不可用，因为它们在二进制库文件中没有有意义的表示。

## 跨语言边界的类型

对于 `FFI` 来说，类型布局至关重要；如果一种语言以一种方式布局某些共享数据的内存，而 `FFI` 边界另一端的语言却要求不同的布局方式，那么两端的数据解释就会不一致。在本节中，我们将探讨如何在 `FFI` 上实现类型匹配，以及在跨越语言界限时需要注意的类型方面的其他方面。

### 类型匹配

类型不会跨 `FFI` 边界共享。在 Rust 中声明类型时，该类型信息在编译时会完全丢失。传递给另一端的只是构成该类型值的位。因此，您需要在边界两侧声明这些位的类型。声明该类型的 Rust 版本时，首先必须确保类型中包含的原语匹配。例如，如果边界另一侧使用 C 语言，并且 C 类型使用 `int`，Rust 代码最好使用与之完全对应的 Rust 类型：`i32`。为了减少这个过程中的一些猜测，对于使用类 C 类型的接口，Rust 标准库在 `std::os::raw` 模块中提供了正确的 C 类型，该模块定义了 `c_int` 类型 = `i32`，`c_char` 类型 = `i8/u8`（取决于 char 是否带符号），`c_long` 类型 = `i32/i64`（取决于目标指针宽度），等等。

> 特别注意 C 语言中一些特殊的整数类型，例如 `__be32`。这些类型通常不会直接转换为 Rust 类型，最好保留为 `[u8; 4]` 之类的格式。例如，`__be32` 始终采用大端编码，而 Rust 的 `i32` 则使用当前平台的字节序。

&nbsp;&nbsp;&nbsp;&nbsp;对于更复杂的类型，例如向量和字符串，通常需要手动进行映射。例如，由于 C 语言倾向于将字符串表示为以 0 字节结尾的字节序列，而不是长度单独存储的 UTF-8 编码字符串，因此通常无法在 `FFI` 上使用 Rust 的字符串类型。相反，假设对方使用 C 风格的字符串表示，则应该分别使用 `std::ffi::CStr` 和 `std::ffi::CString` 类型来表示借用字符串和拥有字符串。对于向量，您可能希望使用指向第一个元素的原始指针，然后单独传递长度——`Vec::into_raw_parts` 方法可能对此很方便。

&nbsp;&nbsp;&nbsp;&nbsp;对于包含其他类型的类型（例如结构体和联合），你还需要处理布局和对齐。正如我们在第二章中讨论的那样，Rust 默认以未定义的方式布局类型，因此你至少需要使用 
`#[repr(C)]` 来确保该类型具有确定性的布局和对齐，以反映（可能且希望）跨 `FFI` 边界使用的内容。如果接口还为该类型指定了其他配置，例如手动设置其对齐方式或移除填充，则需要相应地调整 
`#[repr]`。

&nbsp;&nbsp;&nbsp;&nbsp;Rust 枚举有多种可能的 C 风格表示，具体取决于它是否包含数据。考虑一个没有数据的枚举，如下所示：

```rust
enum Foo { Bar, Baz }
```

&nbsp;&nbsp;&nbsp;&nbsp;使用 `#[repr(C)]` 时，类型 `Foo` 仅使用一个整数进行编码，其大小与 C 编译器为具有相同数量变体的枚举选择的大小相同。第一个变体的值为 0，第二个变体的值为 1，
依此类推。您也可以手动为每个变体赋值，如清单 11-3 所示。

```rust
#[repr(C)]
enum Foo {
 Bar = 1,
 Baz = 2,
}

// 示例 11-3：为无数据枚举定义显式变体值
```

> 从技术角度来看，规范规定第一个变体的值为 0，后续每个变体的值都比前一个变体大 1。如果您手动设置了某些变体的值，而其他变体的值未设置，则会产生差异——未设置的变体将从您上次设置的变体继续使用。

&nbsp;&nbsp;&nbsp;&nbsp;但是，在以这种方式将 C 语言中的类枚举类型映射到 Rust 时，应谨慎行事，因为只有已定义变体的值才对枚举类型的实例有效。这往往会给 C 风格的枚举带来麻烦，因为枚举的功能通常更类似于位集，其中变体可以按位或运算，从而生成一个同时封装多个变体的值。例如，在示例 11-3 的示例中，通过获取 `Bar | Baz` 生成的值 3 对 Rust 中的 `Foo` 无效！如果您需要构建一个 C API，该 API 使用枚举来表示一组可以单独设置和取消设置的位标志，请考虑使用一个新类型包装器来包装整数类型，并为每个变体关联常量，并实现各种 `Bit*` 特征，以改善用户体验。或者使用 `bitflags` `crate`。

&nbsp;&nbsp;&nbsp;&nbsp;对于无字段枚举，您还可以将数字类型传递给 `#[repr]`，以便使用与 `isize` 不同的类型作为鉴别符。例如，`#[repr(u8)]` 将使用单个无符号字节对鉴别符进行编码。对于包含数据的枚举，您可以传递 `#[repr(C, u8)]` 来获得相同的效果。

&nbsp;&nbsp;&nbsp;&nbsp;对于包含数据的枚举，`#[repr(C)]` 属性会导致枚举使用带标记的联合体来表示。也就是说，它在内存中表示为一个包含两个字段的 `#[repr(C)]` 结构体，其中第一个字段是鉴别符，如果所有变体都没有字段，则会按此方式进行编码；第二个字段是每个变体的数据结构的联合体。举一个具体的例子，请考虑清单 11-4 中的枚举及其关联表示。

```rust
#[repr(C)]
enum Foo {
 Bar(i32),
 Baz { a: bool, b: f64 }
}
// is represented as
#[repr(C)]
enum FooTag { Bar, Baz }
#[repr(C)]
struct FooBar(i32);
#[repr(C)]
struct FooBaz{ a: bool, b: f64 }
#[repr(C)]
union FooData {
 bar: FooBar,
 baz: FooBaz,
}
#[repr(C)]
struct Foo {
 tag: FooTag,
 data: FooData
}

// 列表 11-4：带有 #[repr(C)] 的 Rust 枚举表示为带标签的联合 
```

> FFI中的利基优化
>
> 在第九章中，我们讨论了利基优化，Rust 编译器使用无效的位模式来表示不包含数据的枚举变量。这种优化的保证导致了与 `FFI` 的有趣交互。具体来说，这意味着可空指针始终可以使用 `Option` 包装的指针类型在 `FFI` 类型中表示。例如，可空函数指针可以表示为 `Option<extern fn(...)>`，可空数据指针可以表示为 `Option<*mut T>`。如果提供的是全零的位模式值，它们将透明地执行正确的操作，并在 Rust 中将其表示为 `None`。


### 分配

当你分配内存时，该分配属于其分配器，并且只能由同一个分配器释放。如果你在 Rust 中使用多个外部函数接口分配器，或者你同时在 Rust 中分配内存，并且使用 `FFI` 边界另一侧的某个分配器，情况也是如此。你可以自由地跨越边界发送指针并随心所欲地访问该内存，但当再次释放内存时，需要将其返回给相应的分配器。

&nbsp;&nbsp;&nbsp;&nbsp;大多数 FFI 接口会采用以下两种配置之一来处理分配：要么由调用者提供指向内存块的数据指针，要么接口公开专用的释放方法，当不再需要已分配的资源时，应将其返回给这些方法。清单 11-5 展示了一些使用实现管理内存的 `OpenSSL` 库签名的 Rust 声明示例。

```rust
// One function allocates memory for a new object.
extern fn ECDSA_SIG_new() -> *mut ECDSA_SIG;
// And another accepts a pointer created by new
// and deallocates it when the caller is done with it.
extern fn ECDSA_SIG_free(sig: *mut ECDSA_SIG);

// 清单 11-5：实现管理的内存接口
```

&nbsp;&nbsp;&nbsp;&nbsp;函数 `ECDSA_SIG_new` 和 `ECDSA_SIG_free` 组成一对函数，调用者应该调用 `new` 函数，根据需要使用返回的指针（可能依次将其传递给其他函数），然后在处理完引用的资源后，将指针传递给 `free` 函数。据推测，实现会在 `new` 函数中分配内存，并在 `free` 函数中释放内存。如果这些函数是在 `Rust` 中定义的，那么 `new` 函数很可能会使用 `Box::new`，而 `free` 函数会调用 `Box::from_raw`，然后丢弃该值并运行其析构函数。

&nbsp;&nbsp;&nbsp;&nbsp;清单 11-6 显示了调用者管理内存的一个例子。

```rust
// An example of caller-managed memory.
// The caller provides a pointer to a chunk of memory,
// which the implementation then uses to instantiate its own types.
// No free function is provided, as that happens in the caller.
extern fn BIO_new_mem_buf(buf: *const c_void, len: c_int) -> *mut BIO

// 清单 11-6：调用者管理的内存接口
```

&nbsp;&nbsp;&nbsp;&nbsp;这里，`BIO_new_mem_buf` 函数让调用者提供备用内存。调用者可以选择在堆上分配内存，或者使用其认为合适的任何其他机制来获取所需的内存，然后将其传递给库。调用者有责任确保该内存稍后被释放，但只有在 `FFI` 实现不再需要它时才会这样做！

&nbsp;&nbsp;&nbsp;&nbsp;您可以在 `FFI` API 中使用其中任何一种方式，甚至可以根据需要混合使用。一般来说，在可行的情况下，允许调用者传入内存，因为这赋予调用者更大的自由度，使其能够根据自身情况管理内存。例如，调用者可能在某些自定义操作系统上使用高度专业化的分配器，并且可能不希望被迫使用您的实现将使用的标准分配器。如果调用者可以传入内存，它甚至可以完全避免分配，前提是它可以使用堆栈内存或重用已分配的内存。但是，请记住，调用者管理的接口的人体工程学通常更加复杂，因为调用者必须自己完成所有工作来确定要分配多少内存，然后进行设置，然后才能调用您的库。

&nbsp;&nbsp;&nbsp;&nbsp;在某些情况下，调用者甚至可能无法提前知道需要分配多少内存。例如，如果库的类型不透明（因此调用者无法得知）或会随时间变化，调用者将无法预测分配的大小。同样，如果代码在运行时需要分配更多内存，例如，您正在动态构建图，则所需的内存量可能会在运行时动态变化。在这种情况下，您必须使用实现管理的内存。

&nbsp;&nbsp;&nbsp;&nbsp;当你被迫做出权衡时，对于任何大型或频繁的操作，都应选择由调用者分配内存。在这种情况下，调用者可能最关心的是控制分配本身。对于其他情况，你的代码可以为每个相关类型分配内存，然后公开析构函数。

### 回调

只要函数指针的类型具有与函数调用约定匹配的 `extern` 注释，您就可以跨 `FFI` 边界传递函数指针，并通过这些指针调用被引用的函数。也就是说，您可以在 Rust 中定义 `extern "C" fn(c_int) -> c_int`，然后将该函数的引用作为回调传递给 C 代码，C 代码最终会调用该回调。

&nbsp;&nbsp;&nbsp;&nbsp;在`panics`周围使用回调函数时务必谨慎，因为如果`panics`发生在非 `extern “Rust”` 函数的末尾，则`panics`会展开，这是未定义的行为。Rust 编译器目前会在检测到此类`panics`时自动中止，但这并非总是您想要的行为。您可以尝试使用 `std::panic::catch_unwind` 来检测任何标记为 `extern` 的函数中的恐慌，然后将`pancis`转换为与 FFI 兼容的错误。

### 安全

当你编写 Rust `FFI` 绑定时，大多数实际与 `FFI` 接口的代码都是不安全的，并且主要围绕原始指针。然而，你的目标应该是最终在 `FFI` 之上呈现一个安全的 Rust 接口。实现这一点主要在于仔细阅读你正在包装的不安全接口的不变量，然后确保在安全接口中通过 Rust 类型系统维护它们。安全封装外部接口的三个最重要的要素是：准确捕获 `&` 与 `&mut`、正确实现 `Send` 和 `Sync`，以及确保指针不会被意外混淆。接下来我将介绍如何强制执行这三个要素。

#### 引用和生命周期

如果外部代码有可能修改给定指针后面的数据，请确保安全的 Rust 接口通过 `&mut` 来独占引用相关数据。否则，安全包装器的用户可能会意外地从内存中读取外部代码正在同时修改的数据，然后一切就都乱套了！

&nbsp;&nbsp;&nbsp;&nbsp;您还需要充分利用 Rust 的生命周期机制，以确保所有指针的存活时间与 `FFI` 所需的时间一致。例如，假设有一个外部接口，它允许您创建一个 `Context`，然后允许您从该 `Context` 创建一个 `Device`，并且要求 `Context` 在 `Device` 存活期间保持有效。在这种情况下，该接口的任何安全包装器都应在类型系统中强制执行该要求，方法是让 `Device` 持有一个与创建 `Device` 时所借用的 `Context` 相关联的生命周期。

#### Send 和 Sync

不要为外部库中的类型实现 `Send` 和 `Sync` 函数，除非该库明确声明这些类型是线程安全的！安全的 Rust 包装器的作用是确保安全的 Rust 代码不会违反外部代码的不变量，从而触发未定义的行为。

&nbsp;&nbsp;&nbsp;&nbsp;有时，你甚至可能想要引入虚拟类型来强制执行外部不变量。例如，假设你有一个事件循环库，其接口如清单 11-7 所示。

```rust
extern fn start_main_loop();
extern fn next_event() -> *mut Event;

// 示例 11-7：期望单线程使用的库
```

&nbsp;&nbsp;&nbsp;&nbsp;现在假设外部库的文档指出，`next_event` 只能由调用 `start_main_loop` 的同一线程调用。然而，这里我们没有可以避免为其实现 `Send` 的类型！相反，我们可以借鉴第三章的做法，引入额外的标记状态来强制执行不变量，如示例 11-8 所示。

```rust
pub struct EventLoop(std::marker::PhantomData<*const ()>);
pub fn start() -> EventLoop {
 unsafe { ffi::start_main_loop() };
 EventLoop(std::marker::PhantomData)
}
impl EventLoop {
 pub fn next_event(&self) -> Option<Event> {
 let e = unsafe { ffi::next_event() };
 // ...
 }
}

// 示例 11-8：通过引入辅助类型来强制执行 FFI 不变量
```

&nbsp;&nbsp;&nbsp;&nbsp;空类型 EventLoop 实际上并不与底层外部接口中的任何内容连接，而是强制执行以下约定：仅在调用 `start_main_loop` 之后调用 `next_event`，并且只能在同一线程中调用。通过使 `EventLoop` 既不是 `Send` 也不是 `Sync`，即让它持有一个幻像原始指针（它本身既不是 `Send` 也不是 `Sync`），可以强制执行“同一线程”这一部分。

&nbsp;&nbsp;&nbsp;&nbsp;像我们这里这样使用 `PhantomData<*const ()>` 来“撤销” `Send` 和 `Sync` 自动特征，这有点丑陋且不直接。Rust 确实有一个不稳定的编译器特性，可以实现像 `impl !Send for EventLoop {}` 这样的负面特征，但要正确实现它却出奇地困难，而且它可能在一段时间内都无法稳定下来。

&nbsp;&nbsp;&nbsp;&nbsp;你可能已经注意到，没有什么可以阻止调用者多次调用`start_main_loop`，无论是从同一个线程还是从另一个线程。如何处理这个问题取决于相关库的语义，所以我把它留给你作为练习。

#### 指针混乱

在许多 `FFI` API 中，你并不一定希望调用者知道你提供给它的每一个内存块的内部表示。该类型可能具有调用者不应该修改的内部状态，或者该状态可能难以以跨语言兼容的方式表达。对于这种情况，C 风格的 API 通常会暴露 `void` 指针，写为 C 类型 `void*`，这相当于 Rust 中的 `*mut std::ffi::c_void`。像这样的类型擦除指针实际上只是一个指针，并没有传达任何关于它指向的对象的信息。因此，这类指针通常被称为不透明指针。

&nbsp;&nbsp;&nbsp;&nbsp;不透明指针实际上充当了跨 FFI 边界类型的可见性修饰符——由于方法签名并未说明指针指向的内容，调用者只能原样传递指针，并使用任何可用的 `FFI` 方法来提供对所引用数据的可见性。遗憾的是，由于两个 `*mut c_void` 之间难以区分，因此用户可以直接获取 `FFI` 方法返回的不透明指针，并将其提供给需要指向不同不透明类型的指针的方法。

&nbsp;&nbsp;&nbsp;&nbsp;在 Rust 中，我们可以做得更好。为了缓解这种指针类型混淆，我们可以避免在 `FFI` 中直接对不透明指针使用 `*mut c_void` ，即使实际接口调用的是 `void*` ，而是为每个不同的不透明类型构造不同的空类型。例如，在示例 11-9 中，我使用了两种不同的、不会混淆的不透明指针类型。

```rust
#[non_exhaustive] #[repr(transparent)] pub struct Foo(c_void);
#[non_exhaustive] #[repr(transparent)] pub struct Bar(c_void);
extern {
 pub fn foo() -> *mut Foo;
 pub fn take_foo(arg: *mut Foo);
 pub fn take_bar(arg: *mut Bar);
}

// 示例 11-9：无法混淆的不透明指针类型
```

&nbsp;&nbsp;&nbsp;&nbsp;由于 `Foo` 和 `Bar` 都是零大小类型，因此它们可以代替外部方法签名中的 `()`。更棒的是，由于它们现在是不同的类型，Rust 不允许你在需要使用其中一种类型时使用另一种类型，所以现在无法使用从 `foo` 返回的指针来调用 `take_bar`。添加 `#[non_exhaustive]` 注释可确保 `Foo` 和 `Bar` 类型无法在此 `crate` 之外构造。

### bindgen 和构建脚本

为大型外部库映射 Rust 类型和外部函数可能是一项相当繁琐的工作。大型库往往拥有数量众多的类型和方法签名，因此编写所有 Rust 等效函数非常耗时。此外，它们还包含大量极端情况和 C 语言的怪异之处，因此某些模式的转换必然需要更仔细的思考。


&nbsp;&nbsp;&nbsp;&nbsp;幸运的是，Rust 社区开发了一个名为 `bindgen` 的工具，只要你有想要接口的库的 C 头文件，它就可以显著简化这个过程。`bindgen` 本质上编码了我们在本章中讨论的所有规则和最佳实践，以及许多其他规则和最佳实践，并将它们包装在一个可配置的代码生成器中，该生成器接收 C 头文件并输出相应的 Rust 等效代码。

&nbsp;&nbsp;&nbsp;&nbsp;`bindgen` 提供了一个独立的二进制文件，可以一次性生成 C 头文件的 Rust 代码，这在您需要签入绑定时非常方便。此过程允许您根据需要手动调整生成的绑定。另一方面，如果您希望在每次构建时自动生成绑定，并且只需在源代码中包含 C 头文件，`bindgen` 也提供了一个库，您可以在包的自定义构建脚本中调用它。

> 如果您直接签入绑定，请记住它们仅在其生成平台正确。在构建脚本中生成绑定将专门针对当前目标平台生成它们，这不太可能导致与平台相关的布局不一致。

&nbsp;&nbsp;&nbsp;&nbsp;通过在 `Cargo.tom`l 文件的 `[package]` 部分添加 `build = "<some-file.rs>"` 来声明构建脚本。这会告诉 `Cargo`，在编译你的 `crate` 之前，它应该将 `<some-file.rs>` 编译为独立的 Rust 程序并运行；只有这样，它才会编译你的 `crate` 的源代码。构建脚本也拥有自己的依赖项，你可以在 `Cargo.toml` 文件的 `[builddependencies]` 部分中声明这些依赖项。

> 如果您将构建脚本命名为 `build.rs`，则无需在 `Cargo.toml` 中声明它。

&nbsp;&nbsp;&nbsp;&nbsp;构建脚本在 `FFI` 中非常实用——它们可以从源代码编译捆绑的 C 库，动态发现并声明要传递给编译器的附加构建标志，声明 `Cargo` 应该检查更改以便重新编译的其他文件，并且，你猜对了，还可以动态生成其他源文件！

&nbsp;&nbsp;&nbsp;&nbsp;虽然构建脚本用途广泛，但要注意不要让它们过于依赖运行环境。虽然你可以使用构建脚本来检测 Rust 编译器版本是否为素数，或者伊斯坦布尔明天是否会下雨，但让你的编译依赖于这些条件可能会导致其他开发者的构建意外失败，从而导致糟糕的开发体验。

&nbsp;&nbsp;&nbsp;&nbsp;构建脚本可以将文件写入通过 `OUT_DIR` 环境变量提供的特殊目录。相同的目录和环境变量在编译时也可以在 Rust 源代码中访问，以便它可以获取构建脚本生成的文件。要从 C 头文件生成并使用 Rust 类型，首先需要构建脚本使用 `bindgen` 的库版本读取 `.h` 文件，并将其转换为名为 `bindings.rs` 的文件，该文件位于 `OUT_DIR` 目录中。然后，在 `crate` 中的任何 Rust 文件中添加以下行，以便在编译时包含 `bindings.rs`：

```rust
include!(concat!(env!("OUT_DIR"), "/bindings.rs"));
```

&nbsp;&nbsp;&nbsp;&nbsp;由于 `bindings.rs` 中的代码是自动生成的，因此最佳做法通常是将绑定放在各自的 `crate` 中，并将 `crate` 命名为与其对应的库相同的名称，并添加后缀 `-sys`（例如，`openssl-sys`）。如果不遵循此做法，发布库的新版本将会更加麻烦，因为在给定的构建中，两个通过 `Cargo.toml` 中的 `links` 键链接到同一个外部库的 `crate` 共存是违法的。您实际上必须一次性将整个生态系统升级到库的新主版本。将绑定单独放入各自的 `crate` 中，可以让您发布包装器 `crate` 的新主版本，并可以逐步采用。这种分离还允许你在 Rust 绑定发生变化时（例如，如果头文件本身升级，或者 `bindgen` 升级导致生成的 Rust 代码发生轻微变化），发布包含这些绑定的 `crate` 的中断版本，而无需同时发布安全包装 `FFI` 绑定的 `crate` 的中断版本。

&nbsp;&nbsp;&nbsp;&nbsp;如果您的 `crate` 生成的是库文件，并希望其他人通过 `FFI` 使用，那么您还应该为其接口发布一个 C 头文件，以便更容易地从其他语言生成到您库的原生绑定。但是，随着 `crate` 的变化，该 C 头文件也需要保持更新，而这在库规模扩大时会变得非常繁琐。幸运的是，Rust 社区也开发了一个工具来自动化此任务：`cbindgen`。与 `bindgen` 类似，`cbindgen` 也是一个构建工具，它也同时提供二进制文件和库文件，可用于构建脚本。它不是接收 C 头文件并生成 Rust，而是接收 Rust 并生成一个 C 头文件。由于 C 头文件代表了 `crate` 的 `FFI` 的主要计算机可读描述，因此我建议您手动检查它，以确保自动生成的 C 代码不会过于繁琐，尽管通常情况下，`cbindgen` 生成的代码往往相当合理。如果没有，请提交Bug！

> C++
>
> 本章主要关注 C 语言，因为它是最常用于描述可链接库的跨语言接口的语言。由于 C 库无处不在，几乎每种编程语言都提供了与 C 库交互的方式。虽然 C++ 给人的感觉与 C 语言非常相似，而且许多知名库都是用 C++ 编写的，但在 `FFI` 方面，C++ 则截然不同。生成类型和签名以匹配 C 头文件相对简单，但 C++ 却并非如此。在撰写本文时，`bindgen` 对生成 C++ 绑定提供了不错的支持，但它们通常缺乏人机工程学。例如，您通常必须手动调用构造函数、析构函数、重载运算符等。一些 C++ 特性（例如模板特化）也完全不受支持。如果您确实需要与 C++ 交互，我建议您尝试一下 `cxx` crate。

# 总结

在本章中，我们介绍了如何使用 `extern` 关键字将 Rust 调用到外部代码，以及如何使用它使 Rust 代码可以被外部代码访问。我们还讨论了如何将 Rust 类型与 `FFI` 边界另一端的类型对齐，以及在尝试使两种不同语言编写的代码良好地融合时的一些常见陷阱。最后，我们讨论了 `bindgen` 和 `cbindgen` 工具，它们使保持 `FFI` 绑定更新的体验更加愉悦。在下一章中，我们将研究如何在更受限制的环境中（例如嵌入式设备）使用 Rust，在这些环境中，标准库可能不可用，甚至像分配内存这样的简单操作也可能无法实现。


















