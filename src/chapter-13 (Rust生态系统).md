# 第十三章 - Rust生态系统

如今，编程很少在真空中进行——几乎你构建的每个 Rust 箱都可能依赖于一些并非由你编写的代码。这种趋势究竟是好是坏，还是两者兼而有之，是一个备受争议的话题，但无论如何，它都是当今开发者体验的现实。

&nbsp;&nbsp;&nbsp;&nbsp;在这个相互依存的美丽新世界里，牢牢掌握可用的库和工具，并及时了解 Rust 社区提供的最新和最棒的功能，比以往任何时候都更加重要。本章致力于讲解如何利用、追踪、理解并回馈 Rust 生态系统。由于这是最后一章，在结尾部分，我还将提供一些额外的资源建议，供您探索，以继续提升您的 Rust 技能。

## 那里有什么？

尽管 Rust 相对年轻，但它已经拥有一个足够庞大的生态系统，以至于很难追踪所有可用的资源。如果你知道自己想要什么，你或许可以搜索到一组合适的 `crate`，然后使用下载统计数据并对每个 `crate` 的仓库进行粗略的氛围检查，以确定哪些 `crate` 可以构成合理的依赖关系。然而，还有大量的工具、`crate` 和通用语言功能，你可能并不一定知道要寻找它们，但它们可能会为你节省无数的时间和艰难的设计决策。

&nbsp;&nbsp;&nbsp;&nbsp;在本节中，我将介绍一些多年来我发现有用的工具、库和 Rust 功能，希望它们也能在未来为你提供帮助！

## 工具

首先，以下是我经常使用的一些 Rust 工具，你应该将它们添加到你的工具箱中：

### cargo-deny

提供一种方法来检查依赖关系图。在撰写本文时，您可以使用 `cargo-deny` 来仅允许某些许可证、拒绝列出 `crate` 或特定 `crate` 版本、检测存在已知漏洞的依赖项或使用 Git 源的依赖项，以及检测依赖关系图中多次出现且版本不同的 `crate`。当您阅读本文时，可能已经存在更多便捷的 lint 工具。

### cargo-expand

扩展给定 `crate` 中的宏并允许您检查输出，这使得更容易发现宏转录器或程序宏中深层的错误。当您编写自己的宏时，`cargo-expand` 是一个非常有用的工具。

### cargo-hack

帮助您检查您的 `crate` 是否能够在任何启用的功能组合下正常工作。该工具提供的界面与 `Cargo` 本身类似（例如 `Cargo` 的检查、构建和测试），但允许您使用 `crate` 功能的所有可能组合（即功能集）运行给定的命令。

### cargo-llvm-lines

分析从 Rust 代码到中间表示 (IR) 的映射，该中间表示会传递给 Rust 编译器中实际生成机器码的部分 (LLVM)，并告诉您哪些 Rust 代码会生成最大的 IR。这很有用，因为更大的 IR 意味着更长的编译时间，因此识别哪些 Rust 代码会生成更大的 IR（例如由于单态化）可以突出显示缩短编译时间的机会。

### cargo-outdated

检查您的任何依赖项（无论是直接依赖项还是传递依赖项）是否有可用的更新版本。至关重要的是，与 `cargo update` 不同，它甚至会告知您新的主版本号，因此它是检查您是否由于主版本号说明符过期而错过更新版本的重要工具。请记住，如果您在接口中暴露了依赖项的类型，则更改依赖项的主版本号可能会对您的 `crate` 造成重大更改！

### cargo-udeps

识别 `Cargo.toml` 中列出的所有从未实际使用过的依赖项。也许您以前使用过它们，但现在已经变得多余，或者它们应该被移至 dev-dependencies；无论如何，此工具都可以帮助您减少依赖项闭包中的臃肿内容。

&nbsp;&nbsp;&nbsp;&nbsp;虽然 `fd` 和 `ripgrep` 并非专门用于 Rust 开发的工具，但我强烈推荐它们——它们比之前的 `find` 和 `grep` 有了很大的改进，而且它们本身也是用 Rust 编写的。我每天都会用到它们。

## 库

接下来介绍一些实用但不太为人所知的 `crate`，我经常使用它们，而且我估计我会长期依赖它们：

### bytes

提供了一种高效的机制，用于传递单块连续内存的子切片，而无需复制或处理生命周期。这在低级网络代码中非常有用，因为您可能需要将多个视图合并到单个字节块中，而复制是不允许的。

### criterion

一个统计驱动的基准测试库，它利用数学原理消除基准测试测量中的噪声，并可靠地检测性能随时间的变化。如果你的 crate 中包含微基准测试，那么你几乎肯定会使用它。

### cxx

提供了一种安全且符合人体工程学的机制，用于从 Rust 调用 C++ 代码，以及从 C++ 调用 Rust 代码。如果您愿意投入一些时间提前更彻底地声明接口，以换取更好的跨语言兼容性，那么这个库非常值得您关注。

### flume

实现了一个比 Rust 标准库中更快、更灵活、更简单的多生产者、多消费者通道。它同时支持异步和同步操作，是连接这两个世界的桥梁。

### hdrhistogram

高动态范围 (HDR) 直方图数据结构的 Rust 移植，它能够以紧凑的方式表示各种值范围内的直方图。如果您目前跟踪的是平均值或最小/最大值，那么 HDR 直方图或许更适合您；它可以让您更好地洞察指标的分布情况。

### heapless

提供不使用堆的数据结构。相反，无堆的数据结构全部由静态内存支持，这使得它们非常适合嵌入式环境或其他不需要分配内存的情况。

### itertools

扩展了标准库中的 `Iterator` 特性，新增了许多便捷的方法，用于去重、分组和计算幂集。这些扩展方法可以显著减少代码中的样板，例如，手动实现一些针对值序列的常用算法，例如同时查找最小值和最大值 (`Itertools::minmax`)，或者使用一些常用模式，例如检查迭代器是否恰好包含一个项 (`Itertools::exactly_one`)。

### nix

提供与类 Unix 系统上的系统调用的惯用绑定，这比直接使用 libc 之类的库时自行拼凑 C 兼容的 FFI 类型要好得多。

### pin-project

提供宏来强制执行带注释类型的固定安全不变量，从而为这些类型提供安全的固定接口。这可以让你省去为自定义类型设置固定和取消固定的大部分麻烦。此外，还有 `pin-project-lite`，它避免了（目前）对过程式宏机制的过度依赖，但代价是人机工程学略差。

### ring

它汲取了用 C 语言编写的加密库 `BoringSSL` 的优秀部分，并通过一个快速、简单且不易被滥用的接口将它们引入 Rust。如果您需要在自己的 `crate` 中使用加密技术，这是一个很好的起点。您很可能已经在 `rustls` 库中遇到过它，它使用 `ring` 提供了一个现代的、默认安全的 `TLS` 堆栈。

### slab

实现一个高效的数据结构，用于替代 HashMap<Token, T>。其中 Token 是一个不透明类型，仅用于区分映射中的条目。这种模式在管理资源时经常出现，当前资源集合必须集中管理，但各个资源也必须以某种方式访问。

### static_assertions

提供静态断言——即在编译时执行的断言，因此可能在编译时失败。您可以使用它来断言诸如某个类型实现了给定的特征（例如 `Send`）或具有给定的大小之类的事情。我强烈建议在那些保证可能很重要的代码中添加此类断言。

### structopt

包装了著名的参数解析库 `clap`，并提供了一种使用 Rust 类型系统（以及宏注释）来完整描述应用程序命令行界面的方法。解析应用程序的参数时，您将获得定义类型的值，从而获得所有类型检查的优势，例如详尽匹配和 IDE 自动完成。

### thiserror

让编写自定义枚举错误类型（例如我们在第 4 章中讨论过的类型）变得轻松愉快。它负责实现推荐的 `trait`，并遵循既定的约定，您只需定义应用程序独有的关键部分。

### tower

有效地采用了函数签名 `async fn(Request) -> Response`，并在其之上实现了一个完整的生态系统。其核心是 `Service trait`，它表示一种可以将请求转换为响应的类型（我猜测未来有一天可能会将其添加到标准库中）。这是一个很好的抽象，可以在其上构建任何看起来像服务的东西。

### tracing

提供高效追踪应用程序执行所需的所有管道。至关重要的是，它与您正在追踪的事件类型以及您想要如何处理这些事件无关。该库可用于日志记录、指标收集、调试、分析以及追踪，所有这些都使用相同的机制和接口。

## Rust工具

Rust 工具链有一些你可能不知道的功能。这些功能通常针对非常具体的用例，但如果它们符合你的要求，它们可能会成为你的救星！

### Rustup

Rustup，Rust 工具链安装程序，其工作效率极高，以至于它常常被人遗忘。你偶尔会用它来更新工具链、设置目录覆盖或安装组件，但仅此而已。然而，Rustup 支持一个非常实用的技巧，值得了解：工具链覆盖简写。你可以将 +toolchain 作为第一个参数传递给任何 Rustup 管理的二进制文件，该二进制文件将像你为给定的工具链设置覆盖一样运行，运行命令，然后将覆盖重置回之前的状态。因此，cargo +nightly miri 将使用 nightly 工具链运行 Miri，而 cargo +1.53.0 check 将检查代码是否使用 Rust 1.53.0 进行编译。后者对于检查你是否违反了 Rust 的最低支持版本约定特别有用。

&nbsp;&nbsp;&nbsp;&nbsp;Rustup 还有一个简洁的子命令 doc，它可以在浏览器中打开当前 Rust 编译器版本对应的 Rust 标准库文档的本地副本。如果您在没有互联网连接的情况下进行开发，这个命令将非常有用！

### Cargo

`Cargo` 也有一些实用的功能，但并非总是容易发现。首先是 `Cargo tree`，它是 `Cargo` 内置的一个子命令，用于检查 `crate` 的依赖关系图。此命令的主要功能是将依赖关系图打印成树状结构。它本身就很有用，但 `Cargo tree` 真正出彩的地方在于 `--invert` 选项：它接受一个 `crate` 标识符，并生成一个倒置的树状结构，显示从当前 `crate` 引入该依赖关系的所有依赖路径。例如，c`argo tree -i rand` 将打印当前 `crate` 依赖任何版本 `rand` 的所有方式，包括通过传递依赖关系。如果您想消除某个依赖关系，或者某个依赖关系的特定版本，并且想知道为什么它仍然被引入，那么这个命令就非常有用。您还可以传递 `-e features` 选项，以包含有关启用相关 `crate` 的每个 `Cargo` 功能的原因的信息。

&nbsp;&nbsp;&nbsp;&nbsp;说到 `Cargo` 子命令，编写自己的子命令非常容易，无论是与他人共享，还是仅用于您自己的本地开发。当 `Cargo` 被调用时，如果其无法识别子命令，它会检查是否存在名为 `cargo-$subcommand` 的程序。如果存在，`Cargo` 会调用该程序，并将命令行中传递的所有参数传递给它——因此，`cargo foo bar` 会使用参数 `bar` 调用 `cargo-foo`。`Cargo` 甚至会将此命令与 `cargo help` 集成，通过将 `cargo help foo` 转换为对 `cargo-foo --help` 的调用。

&nbsp;&nbsp;&nbsp;&nbsp;随着你开发更多 Rust 项目，你可能会注意到 `Cargo`（以及更广义的 Rust）在磁盘空间方面并不宽容。每个项目都有自己的目标目录来存放其编译工件，随着时间的推移，你最终会积累多个相同的编译工件副本，用于存放常见的依赖项。将每个项目的工件分开存放是一个明智的选择，因为它们不一定在项目之间兼容（例如，如果一个项目使用的编译器标志与另一个项目不同）。但在大多数开发者环境中，共享构建工件是完全合理的，并且在项目之间切换时可以节省大量的编译时间。幸运的是，配置 `Cargo` 共享构建工件非常简单：只需在 `~/.cargo/config.toml` 文件中将 `[build] target` 设置为你希望这些共享工件所在的目录，`Cargo` 会处理剩下的事情。再也看不到目标目录了！只需确保你不时清理该目录，并且要注意，`cargo clean` 命令现在会清理你所有项目的构建工件。

> 对于假设编译器工件始终位于 `target/` 子目录下的项目，使用共享构建目录可能会引发问题，因此请务必注意。另请注意，如果项目使用了不同的编译器标志，则每次移入或移出该项目时，都需要重新编译受影响的依赖项。在这种情况下，最好将该项目的 `Cargo` 配置中的 `target` 目录覆盖到不同的位置。

&nbsp;&nbsp;&nbsp;&nbsp;最后，如果您觉得 `Cargo` 构建 `crate` 的时间过长，可以使用目前不稳定的 `Cargo -Ztimings` 标志。使用该标志运行 `Cargo` 会输出以下信息：处理每个 `crate` 的时间、构建脚本的运行时间、哪些 `crate` 需要等待其他 `crate` 完成编译，以及大量其他有用的指标。这可能会突出显示某个特别慢的依赖链，您可以尝试消除它，或者找到一个从头编译原生依赖项的构建脚本，以便您使用系统库来代替它。如果您想更深入地了解，还可以使用 `rustc -Ztime-passes`，它会输出每个 `crate` 在编译器内部耗时的信息——尽管这些信息可能只有在您希望为编译器本身做出贡献时才有用。

### rustc

Rust 编译器还有一些鲜为人知的功能，但对有进取心的开发者来说可能很有用。首先是目前不稳定的 `-Zprinttype-sizes` 参数，它会打印当前 `crate` 中所有类型的大小。除了最小的 `crate` 之外，它会为所有 `crate` 生成大量信息，但在尝试确定 `memcpy` 调用中意外耗时的来源，或在分配大量特定类型的对象时寻找减少内存使用的方法时，它非常有用。`-Zprint-type-sizes` 参数还会显示每种类型的计算对齐和布局，这可能会指出哪些地方（例如，将 `usize` 转换为 `u32` ）可能会对类型的内存表示产生重大影响。在调试特定类型的大小、对齐和布局后，我建议添加静态断言，以确保它们不会随着时间的推移而退化。您可能还会对 `variant_size_differences lint` 感兴趣，如果 `crate` 包含的枚举类型的变体大小差异很大，它会发出警告。

&nbsp;&nbsp;&nbsp;&nbsp;要使用特定标志调用 `rustc`，您有几种选择：您可以在 `RUSTFLAGS` 环境变量中设置它们，或者在 `.cargo/config.toml` 文件中设置 `[build] rustflags`，以便将它们应用于从 `Cargo` 调用 `rustc` 的每次操作；或者，您可以使用 `cargo rustc`，它会将您提供的任何参数仅传递给当前 `crate` 的 `rustc` 调用。

&nbsp;&nbsp;&nbsp;&nbsp;如果您的分析示例看起来很奇怪，堆栈帧被重新排序或完全缺失，您也可以尝试 `-Cforce-frame-pointers = yes`。帧指针提供了一种更可靠的方法来展开堆栈（这在分析过程中经常使用），但代价是需要使用一个额外的寄存器来处理函数调用。虽然只需启用常规调试符号（请记住在使用发布配置文件时设置 `debug = true`）即可正常展开堆栈，但情况并非总是如此，帧指针可能会解决您遇到的任何问题。

## 标准库

Rust 标准库通常被认为比其他编程语言的标准库规模较小，但它在广度上的不足，却在深度上得到了弥补；在 Rust 的标准库中，你找不到 Web 服务器实现或 X.509 证书解析器，但你会发现 Option 类型拥有 40 多种不同的方法以及 20 多个 trait 实现。对于它所包含的类型，Rust 会尽力提供所有能够显著提升代码效率的相关功能，从而避免那些可能轻易出现的冗长的样板代码。在本节中，我将介绍一些标准库中你可能从未见过的类型、宏、函数和方法，它们通常可以简化或改进（或两者兼而有之）你的代码。

### 宏和函数

让我们从几个独立的实用程序开始。首先是 `write!` 宏，它允许你使用格式字符串将数据写入文件、网络套接字或任何实现了 `Write` 接口的对象。你可能已经很熟悉它了——但 write! 有一个鲜为人知的特性：它同时兼容 `std::io::Write` 和 `std::fmt::Write`，这意味着你可以用它将格式化的文本直接写入字符串。也就是说，你可以使用 `std::fmt::Write`; `write!(&mut s, "{}+1={}", x, x + 1);` 将格式化的文本附加到字符串 `s!` 后面。

&nbsp;&nbsp;&nbsp;&nbsp;`iter::once` 函数接受任意值并生成一个迭代器，该迭代器会返回该值一次。如果您不想分配内存，或者想调用接受迭代器的函数，或者想与 `Iterator::chain` 结合使用，将单个项附加到现有迭代器，那么 `iter::once` 函数就非常方便了。

&nbsp;&nbsp;&nbsp;&nbsp;我们在第一章简要讨论过 `mem::replace`，但如果你错过了，值得再次回顾一下。此函数接受一个对 T 的独占引用和一个被拥有的 T，交换两者，使引用对象变为被拥有的 T，并返回前一个引用对象的所有权。当你需要在只有独占引用的情况下获取某个值的所有权时，例如在 `Drop` 的实现中，这非常有用。另请参阅 `mem::take` 了解 `T: Default` 的情况。

### 类型

接下来，我们来看看一些常用的标准库类型。对于向底层 I/O 资源发出许多小型读取或写入调用的 I/O 操作，`BufReader` 和 `BufWriter` 类型是必不可少的。这些类型包装了相应的底层读取或写入操作，并自行实现了读取和写入接口，但它们还会对 I/O 资源的操作进行缓冲，以便许多小型读取操作最终只执行一次大型读取操作，而许多小型写入操作最终只执行一次大型写入操作。这可以显著提高性能，因为您不必频繁跨越系统调用屏障进入操作系统。

&nbsp;&nbsp;&nbsp;&nbsp;第三章中提到的 `Cow` 类型在您需要灵活地控制持有类型或返回类型时非常有用。您很少会将 `Cow` 用作函数参数（回想一下，如果需要，您应该让调用者分配内存），但它作为返回类型非常有用，因为它允许您准确地表示可能分配或不分配内存的函数的返回类型。它也非常适合用作输入或输出的类型，例如类 RPC API 中的核心类型。假设我们有一个 EntityIdentifier 类型，如清单 13-1 所示，用于 RPC 服务接口。

```rust
struct EntityIdentifier {
 namespace: String,
 name: String,
}

// 示例 13-1：需要分配的组合输入/输出类型的表示
```

&nbsp;&nbsp;&nbsp;&nbsp;现在设想有两个方法：`get_entity` 接受一个 `EntityIdentifier` 作为参数，而 `find_by` 根据一些搜索参数返回一个 `EntityIdentifier`。`get_entity` 方法只需要一个引用，因为该标识符（大概）会在发送到服务器之前被序列化。但对于 `find_by`，实体将从服务器响应中反序列化，因此必须将其表示为一个拥有所有权的值。如果我们让 `get_entity` 接受 `&EntityIdentifier`，这意味着调用者仍然必须分配拥有所有权的字符串来调用 `get_entity`，即使接口并不要求这样做，因为它首先需要构造一个 E`ntityIdentifier` ！我们可以为 `get_entity` 引入一个单独的类型 `EntityIdenifierRef`，它只包含 `&str` 类型，但这样一来，我们就有两个类型来表示一个事物了。`Cow` 来帮忙了！示例 13-2 展示了一个内部包含 `Cow` 的 `EntityIdentifier`。

```rust
struct EntityIdentifier<'a> {
 namespace: Cow<'a, str>,
 name: Cow<'a str>,
}

// 清单 13-2: 不需要分配的组合输入/输出类型的表示
```

&nbsp;&nbsp;&nbsp;&nbsp;通过这种构造，`get_entity` 可以接受任何 `EntityIdentifier<'_>`，这允许调用者仅使用引用来调用该方法。`find_by` 可以返回 `EntityIdentifier<'static>`，其中所有字段均为 `Cow::Owned`。两个接口共享一种类型，无需任何不必要的分配！

> 如果你以这种方式实现类型，我建议你也提供一个 `into_owned` 方法，通过在所有字段上调用 `Cow::into_owned` 将 `<'a>` 实例转换为 `<'static>` 实例。否则，当用户只有一个 `<'a>` 时，他们将无法创建更持久的克隆类型。

&nbsp;&nbsp;&nbsp;&nbsp;`std::sync::Once` 类型是一个同步原语，允许你在初始化时只运行一次给定的代码片段。这对于 FFI 中的初始化非常有用，因为 FFI 边界另一侧的库要求初始化只执行一次。Rust 1.8 后使用经过封装的更高层的 `std::sync::LazyLock` 代替.

&nbsp;&nbsp;&nbsp;&nbsp; `VecDeque` 类型是 `std::collections` 中一个经常被忽视的成员，我发现自己经常会用到它——基本上，每当我需要一个栈或队列时。它的接口与 `Vec` 类似，并且像 `Vec` 一样，它在内存中的表示也是一块内存。不同之处在于，`VecDeque` 会在单次分配中同时跟踪实际数据的起始和结束。这允许在 `VecDeque` 的任意一侧以恒定时间进行推送和弹出，这意味着它可以用作栈、队列，甚至同时用作两者。但代价是，值在内存中不再一定是连续的（它们可能已经回绕），这意味着 `VecDeque<T>` 没有实现 `AsRef<[T]>` 接口。

### 方法

让我们快速浏览一下一些简洁的方法。首先是 `Arc::make_mut`，它接受一个 `&mut Arc<T>` 并返回一个 `&mut T`。如果该 `Arc` 是最后一个存在的 `Arc`，它会返回 `Arc` 后面的 `T`；否则，它会分配一个新的 `Arc<T>` 来保存 `T` 的一个克隆，将其替换为当前引用的 `Arc`，然后将 `&mut` 赋值给新的单例 `Arc` 中的 `T`。

&nbsp;&nbsp;&nbsp;&nbsp; `Clone::clone_from` 方法是 `.clone()` 的替代形式，它允许你重用你克隆类型的实例，而不是分配一个新的实例。换句话说，如果你已经有一个 `x: T`，你可以执行 `x.clone_from(y)`，而不是 `x = y.clone()`，这样可以节省一些分配。

&nbsp;&nbsp;&nbsp;&nbsp; 如果 `#[derive(Debug)]` 不适用于您的用例（例如，如果您只想包含某些字段，或者公开类型字段的 `Debug` 实现未公开的信息），那么`std::fmt::Formatter::debug_*` 是迄今为止自行实现 `Debug` 的最简单方法。在实现 `Debug` 的 `fmt` 方法时，只需在传入的 `Formatter` 上调用相应的 `debug_` 方法（例如，`debug_struct` 或 `debug_map`），在结果类型上调用包含的方法来填充有关该类型的详细信息（例如，`field` 用来添加字段，`entries` 用来添加键/值条目），然后调用 `finish`。

&nbsp;&nbsp;&nbsp;&nbsp; `Instant::elapsed` 返回 `Instant` 创建以来的持续时间。这比通常创建新 `Instant` 并减去先前实例的方法简洁得多。

&nbsp;&nbsp;&nbsp;&nbsp; `Option::as_deref` 接受一个 `Option<P>` 类型的参数，其中 `P: Deref` 为参数，并返回 `Option<&P::Target>`（此外还有一个 `as_deref_mut` 方法）。这个简单的操作可以避免使用难以理解的 `.as_ref().map(|r| &**r)` 函数，从而使操作 `Option` 的函数转换链更加简洁。

&nbsp;&nbsp;&nbsp;&nbsp; `Ord::clamp` 允许你将任何实现 `Ord` 的类型限制在给定范围内的两个值之间。也就是说，给定一个下限 `min` 和一个上限 `max`，如果 `x` 小于 `min`，则 `x.clamp(min, max)` 返回 `min`；如果 `x` 大于 `max`，则返回 `max`；否则返回 `x`。

&nbsp;&nbsp;&nbsp;&nbsp; `Result::transpose` 及其对应的 `Option::transpose` 会反转嵌套 `Result` 和 `Option` 的类型。也就是说，转置 `Result<Option<T>, E>` 会得到 `Option<Result<T, E>>`，反之亦然。当与 `?` 结合使用时，此操作可以使代码在易错环境中与 `Iterator::next` 及类似方法一起使用时更加简洁。

&nbsp;&nbsp;&nbsp;&nbsp; `Vec::swap_remove` 是 `Vec::remove` 的孪生兄弟，速度更快。`Vec::remove` 会保留向量的顺序，这意味着要移除中间的元素，它必须将向量中所有后面的元素向下移动一位。这对于大型向量来说可能非常慢。另一方面，`Vec::swap_remove` 会将待移除的元素与最后一个元素交换，然后将向量的长度截断一位，这是一个常数时间操作。但请注意，它会重新排列向量，从而使旧索引失效！

## 野范式

当你开始探索非自己编写的代码库时，你可能会遇到一些我们目前为止在书中尚未讨论过的常见 Rust 模式。了解这些模式会让你更容易识别它们，从而在遇到问题时理解它们的用途。

### 索引指针

索引指针允许您在数据结构中存储对数据的多个引用，而不会与借用检查器冲突。例如，如果您想要存储一个数据集合，以便能够以多种方式高效访问它，例如，将一个 `HashMap` 设置为一个字段的键，另一个设置为另一个字段的键，那么您肯定不希望将底层数据也存储多次。您可以使用 `Arc` 或 `Rc`，但它们使用动态引用计数，这会带来不必要的开销，而且额外的簿记需要您为每个条目存储额外的字节。您可以使用引用，但生命周期会变得难以管理，甚至无法管理，因为数据和引用位于同一个数据结构中（正如我们在第 8 章中讨论的那样，它是一个自引用的数据结构）。您可以使用原始指针结合 Pin 来确保指针保持有效，但这会带来很多复杂性以及不安全性，因此您需要仔细考虑。

&nbsp;&nbsp;&nbsp;&nbsp;大多数 `crate` 使用索引指针（或者，我喜欢称之为非引用）。其思路很简单：将每个数据条目存储在某个可索引的数据结构中，例如 `Vec`，然后将索引存储在派生数据结构中。之后，要执行操作，首先使用派生数据结构高效地找到数据索引，然后使用该索引检索引用的数据。无需生命周期——如果您愿意，甚至可以在派生数据表示中使用循环！

&nbsp;&nbsp;&nbsp;&nbsp; `indexmap` `crate` 提供了一个 `HashMap` 实现，其中迭代顺序与 `map` 的插入顺序一致，它很好地体现了这种模式。该实现必须将键存储在两个地方：键到值的映射和所有键的列表中。但显然，它不希望在键类型本身很大的情况下保留两份副本。因此，它使用了索引指针。具体来说，它将所有键/值对保存在一个 `Vec` 中，然后维护一个从键哈希值到 `Vec` 索引的映射。要迭代映射中的所有元素，它只需遍历 `Vec`。要查找给定的键，它会对该键进行哈希处理，然后在映射中查找该哈希值，从而得到该键在 `Vec` 中的索引（索引指针），然后使用该索引从 `Vec` 中获取该键的值。

&nbsp;&nbsp;&nbsp;&nbsp;实现图数据结构和算法的 `petgraph` `crate` 也采用了这种模式。该 `crate` 会将所有节点值存储到一个 `Vec` 中，并将所有边值存储到另一个 `Vec` 中，然后仅使用这些 `Vec` 中的索引来引用节点或边。因此，例如，与一条边关联的两个节点在该边中仅以两个 `u32` 的形式存储，而不是以引用或引用计数值的形式存储。

&nbsp;&nbsp;&nbsp;&nbsp;诀窍在于如何支持删除操作。要删除一个数据条目，首先需要在所有派生数据结构中搜索其索引并删除相应的条目，然后需要从根数据存储中删除该数据。如果根数据存储是 `Vec`，则删除该条目还会更改另一个数据条目的索引（使用 `swap_remove` 时），因此，您需要更新所有派生数据结构，以反映移动条目的新索引。

### Drop 守卫

丢弃保护提供了一种简单而可靠的方法，确保即使在发生panics的情况下，代码也能运行，这在不安全代码中通常至关重要。例如，一个函数接受一个闭包 `f: FnOnce`，并在使用原子操作的互斥机制下执行它。假设该函数使用 `compare_exchange`（第十章讨论过）将一个布尔值从 `false` 设置为 `true`，调用 `f`，然后将布尔值设置回 `false` 以结束互斥。但想象一下，如果 `f` 发生panics会发生什么——该函数将永远无法运行其清理操作，并且其他调用将无法再次进入互斥部分。

&nbsp;&nbsp;&nbsp;&nbsp;虽然可以使用 `catch_unwind` 来解决这个问题，但 `drop guard` 提供了一种通常更符合人体工程学的替代方案。清单 13-3 展示了如何在当前示例中使用 `drop guard` 来确保布尔值始终被重置。

```rust
fn mutex(lock: &AtomicBool, f: impl FnOnce()) {
 // .. while lock.compare_exchange(false, true).is_err() ..
 struct DropGuard<'a>(&'a AtomicBool);
 impl Drop for DropGuard<'_> {
 fn drop(&mut self) {
 lock.store(true, Ordering::Release);
 }
 }
 let _guard = DropGuard(lock);
 f();
}


// 示例 13-3：使用 drop guard 确保代码在恐慌解除后运行
```

&nbsp;&nbsp;&nbsp;&nbsp;我们引入了实现 `Drop` 的本地类型 `DropGuard`，并将清理代码放置在其 `Drop::drop` 的实现中。任何必要的状态都可以通过 `DropGuard` 的字段传入。然后，我们在调用可能引发panics的函数（此处为 `f`）之前构造一个守卫类型的实例。当 `f` 返回时，无论是由于panics还是正常返回，守卫都会被丢弃，其析构函数运行，锁被释放，一切正常。

&nbsp;&nbsp;&nbsp;&nbsp;重要的是，将守卫赋值给一个变量，该变量在作用域末尾（即用户提供的代码执行完毕后）被丢弃。这意味着，即使我们不再引用守卫的变量，也需要为其指定一个名称，因为 `let _ = DropGuard(lock)` 会立即丢弃守卫——甚至在用户提供的代码运行之前！

&nbsp;&nbsp;&nbsp;&nbsp;与 `catch_unwind` 类似，`drop guard` 仅在panics解除时起作用。如果代码在编译时使用了 `panic=abort`，则恐慌解除后不会再运行任何代码。

&nbsp;&nbsp;&nbsp;&nbsp;这种模式经常与线程局部变量结合使用，当库代码希望设置线程局部状态，使其仅在闭包执行期间有效，因此需要在执行结束后清除时使用。例如，在撰写本文时，`Tokio` 使用此模式提供有关执行器调用 `Future::poll` 的信息，以便将信息传递给 `TcpStream` 等叶子资源，而无需通过用户可见的函数签名传播该信息。如果即使在 `Future::poll` 因 `panic` 返回后，线程局部状态仍然指示某个执行器线程处于活动状态，那就不好了，因此 `Tokio `使用 `drop guard` 来确保重置线程局部状态。

&nbsp;&nbsp;&nbsp;&nbsp;您经常会在线程局部变量中使用 `Cell` 或 `Rc<RefCell>`。这是因为线程局部变量只能通过共享引用访问，因为线程可能会再次访问它已经在调用堆栈中更高层级引用的线程局部变量。这两种类型都提供了内部可变性，且不会产生太多开销，因为它们仅适用于单线程使用，因此非常适合此用例。

### 扩展 traits

扩展traits允许 `crate` 为实现了其他 `crate` traits的类型提供额外的功能。例如，`itertools` `crate` 为 `Iterator` 提供了一个扩展特性，它为常见（以及不太常见）的迭代器操作添加了许多便捷的快捷方式。再例如，`tower` 提供了 `ServiceExt`，它添加了几个更符合人体工程学的操作来包装来自 `Tower-service` 的 `Service` 特性中的低级接口。

&nbsp;&nbsp;&nbsp;&nbsp;扩展traits往往在你无法控制基本特性（例如 `Iterator`）时很有用，或者当基本特性位于其自己的 `crate` 中时很有用，因此它很少会遇到重大版本更新，从而不会导致不必要的生态系统分裂（例如 `Service`）。

&nbsp;&nbsp;&nbsp;&nbsp;扩展traits (`trait ServiceExt: Service`) 扩展了它所扩展的基特质，并且仅包含提供的方法。它还附带一个针对任何实现基特质的 T 的统一实现 (`impl<T> ServiceExt for T where T: Service {}`)。这些条件共同确保了扩展特质的方法在任何实现基特质的类上都可用。

### Crate Preludes

在第十二章中，我们讨论了标准库 `prelude`，它使许多类型和 `trait` 自动可用，而无需编写任何 `use` 语句。类似地，导出多个经常一起使用的类型、`trait` 或函数的 `crate`，有时会以名为 `prelude` 的模块的形式定义自己的 `prelude`，该模块重新导出这些类型、`trait` 和函数中一些特别常见的子集。这个模块名称并没有什么神奇之处，也不会自动使用，但它可以向用户发出一个信号，表明他们可能想要在想要使用相应 `crate` 的文件中加上 `use somecrate::prelude::*` 。`*` 是一个全局导入，告诉 Rust 使用指定模块中所有公开可用的项。当 `crate` 包含许多通常需要命名的项时，这可以节省大量的输入工作。

> 通过 `*` 使用的项的优先级低于通过名称明确使用的项。这使得您可以在自己的 `crate` 中定义与标准库 `prelude` 中的内容重叠的项，而无需指定使用哪一个。

&nbsp;&nbsp;&nbsp;&nbsp; `Prelude` 也非常适合暴露大量扩展trait的 `crate`，因为只有定义trait的方法在作用域内时，才能调用这些方法。例如，`Diesel` `crate` 提供了符合人体工程学的关系数据库访问方式，它大量使用了扩展trait，因此您可以编写如下代码：

```rust
posts.filter(published.eq(true)).limit(5).load::<Post>(&connection)
```

只有当所有正确的特质都在范围内时，这一行才会起作用，而前奏会处理好这一点。

&nbsp;&nbsp;&nbsp;&nbsp;一般来说，在代码中添加全局导入时应谨慎，因为它们可能会将指定模块的新增功能转换为不向后兼容的更改。例如，如果有人向你全局导入的模块添加了一个新特性，而该新特性使方法 `foo` 在已有其他 `foo` 方法的类型上可用，那么在该类型上调用 `foo` 的代码将无法编译，因为对 `foo` 的调用现在变得模棱两可。有趣的是，虽然全局导入的存在使得任何模块的新增功能在技术上都是突破性的变更，但 Rust 关于 API 演进的 RFC（RFC 1105；参见 https://rust-lang.github.io/rfcs/1105-api-evolution.html）并不要求库为此类变更发布新的主要版本。 RFC
详细说明了原因，我建议您阅读一下，但要点是小版本发布允许对依赖项进行最小侵入性更改，例如在边缘情况下添加类型注释，因为否则，尽管不太可能真正影响任何消费者，但很大一部分更改仍需要新的主要版本。

&nbsp;&nbsp;&nbsp;&nbsp;具体来说，对于 `prelude` 模块，如果 `vending` `crate` 推荐使用 `glob` 导入，通常就可以了，因为维护者知道他们的用户会使用 `glob` 导入 `prelude` 模块，因此在决定某个变更是否需要进行主要版本升级时会考虑到这一点。

## 保持最新状态

Rust 作为一种新兴语言，正在快速发展。语言本身、标准库、工具以及更广泛的生态系统都仍处于起步阶段，每天都有新的发展。虽然掌握所有变化可能不切实际，但值得你花时间关注重要的发展，这样你才能在项目中充分利用最新、最强大的功能。

&nbsp;&nbsp;&nbsp;&nbsp;要了解 Rust 本身的改进，包括新的语言特性、标准库的添加以及核心工具的升级，Rust 官方博客 https://blog.rust-lang.org/ 是一个不错的入门网站，信息量不大。它主要发布每个 Rust 新版本的公告。我建议你养成阅读这些博客的习惯，因为它们往往包含一些有趣的小知识，这些知识会慢慢加深你对该语言的了解。为了深入了解，我强烈建议你同时阅读 Rust 和 Cargo 的详细更新日志（链接通常位于每个发布公告的底部附近）。更新日志会列出一些在发行说明中不够长篇大论的变更，但这可能正是你在两周后所需要的。想要获取更新频率较低的新闻来源，请查看版本指南 https://doc.rust-lang.org/edition-guide/，其中概述了每个 Rust 版本的新增内容。Rust 版本通常每三年发布一次。

> Clippy 通常能够告诉您何时可以利用新的语言或标准库功能——请始终启用 Clippy！

&nbsp;&nbsp;&nbsp;&nbsp;如果您对 Rust 本身的开发过程感兴趣，不妨订阅“Rust 内部”博客：https://blog.rust-lang.org/inside-rust/。它包含来自各个 Rust 团队的最新消息，以及事件报告、重大变更提案、版本规划信息等等。如果您想亲自参与 Rust 开发——我非常鼓励您这样做，因为这不仅充满乐趣，而且是一次很棒的学习体验——您可以访问 
https://www.rust-lang.org/governance/ 查看各个 Rust 工作组，每个工作组都专注于改进 Rust 的某个特定方面。找到一个您感兴趣的工作组，并在其开会时随时联系，并询问您能提供哪些帮助。您还可以加入社区讨论，讨论 Rust 内部机制，网址为：https://internals.rust-lang.org/；这是深入了解 Rust 设计和开发各个环节的理念的另一个好方法。

&nbsp;&nbsp;&nbsp;&nbsp;与大多数编程语言一样，Rust 的大部分价值源于其社区。Rust 社区成员不仅不断开发新的节省工作量的 `crate`，发现新的 Rust 特有技术和设计模式，而且还共同持续地帮助彼此理解、记录和解释如何最大限度地利用 Rust 语言。本书中涵盖的所有内容，以及更多内容，都已在社区的数千条评论、博客文章以及 Twitter 和 Discord 对话中进行了讨论。即使只是偶尔参与这些讨论，也几乎可以保证你对某个语言特性、技术或 `crate` 有新的了解。

&nbsp;&nbsp;&nbsp;&nbsp; Rust 社区遍布各地，但一些不错的起点包括用户论坛 (https://users.rust-lang.org/)、Rust 子版块 (https://www.reddit.com/r/rust/)、Rust 社区 Discord (https://discord.gg/rust-lang-community) 以及 Rust 推特账号 (https://twitter.com/rustlang)。您无需一直或全部参与这些社区——选择一个您喜欢的社区，偶尔关注一下！

&nbsp;&nbsp;&nbsp;&nbsp;想要随时了解 Rust 的最新进展，一个绝佳的平台是“本周 Rust 博客”（https://this-week-in-rust.org/），它是“Rust 进展和社区的每周总结”。它链接了官方公告和更新日志，以及热门的社区讨论和资源、有趣的新 `crate`、贡献机会、即将举行的 Rust 活动以及 Rust 工作机会。它甚至列出了有趣的语言 RFC 和编译器 PR，所以这个网站真的应有尽有！辨别哪些信息对你有价值，哪些没价值可能有点困难，但即使只是浏览并偶尔点击一些看起来有趣的链接，也能让你源源不断地获得 Rust 的新知识。

> 想查询某个功能何时稳定发布？Can I Use… (https://caniuse.rs/) 可以帮你搞定。

## 接下来做什么？

你已经从头到尾读完了这本书，吸收了它传授的所有知识，并且仍然渴望了解更多？太好了！还有很多其他优秀的资源可以帮助你拓展和加深对 Rust 的了解。在最后一节，我将为你介绍一些我最喜欢的资源，以便你继续学习。我根据不同的学习方式将它们分成了不同的小节，以便你找到适合自己的资源。

> 自学的一个挑战，尤其是在初期，在于进步难以察觉。即使是最简单的实现，也可能需要耗费大量的时间，因为你需要不断查阅文档和其他资源、寻求帮助或进行调试才能了解 Rust 的某些工作原理。所有这些非编码工作，可能会让你感觉像是在原地踏步，并没有真正的进步。但你正在学习，这本身就是一种进步——只是更难察觉和欣赏而已。

### 通过观看学习

观看经验丰富的开发人员编写代码本质上是一个生活小窍门，可以弥补独自学习起步阶段的缓慢。它让你能够观察设计和构建的过程，同时借鉴他人的经验。聆听经验丰富的开发人员清晰地阐述他们的想法，并解释他们遇到的棘手概念或技巧，可以成为独自解决问题的绝佳替代方案。你还可以学习各种辅助知识，例如调试技巧、设计模式和最佳实践。最终，你必须坐下来亲自实践——这是检验你是否真正理解所观察到的内容的唯一方法——但借鉴他人的经验几乎肯定会让早期阶段更加愉快。如果体验是互动的，那就更好了！

因此，以下是我推荐的一些 Rust 视频频道：

不出所料，我的频道是：https://www.youtube.com/c/JonGjengset/。我有一些长篇编码视频和（较短的）基于代码的理论/概念讲解视频，偶尔也会发布一些深入探讨有趣 Rust 编码故事的视频。

超棒的 Rust Streaming 列表：https://github.com/jamesmunns/awesome-rust-streaming/。此资源列出了众多直播 Rust 代码或其他 Rust 内容的开发者。

《Rust in Action》作者 Tim McNamara 的频道：https://www.youtube.com/c/timClicks/。Tim 的频道和我的一样，主要负责实现和理论讲解，不过 Tim 尤其擅长创意视觉项目，这让观看起来非常有趣。

Jonathan Turner 的 Systems with JT 频道：https://www.youtube.com/c/SystemswithJT/。Jonathan 的视频记录了他们在 Nushell 上的工作，他们对“新型 shell”的理解，让大家很好地了解了在复杂的现有代码库上工作是什么样的。

Ryan Levick 的频道：https://www.youtube.com/c/RyanLevicksVideos/。Ryan 主要发布一些视频，讲解特定的 Rust 概念，并使用具体的代码示例进行讲解。但他偶尔也会发布一些实现视频（例如 Microsoft Flight Simulator 的 FFI！），并深入探讨一些知名 `crate` 的底层工作原理。

&nbsp;&nbsp;&nbsp;&nbsp;鉴于我制作 Rust 视频，我很喜欢这种教学方式也就不足为奇了。但这种接受式或互动式学习并不一定非要以视频的形式呈现。另一个向经验丰富的开发人员学习的好方法是结对编程。如果你有同事或朋友精通 Rust 的某个方面，而你想学习，不妨问问他们能否和你一起进行结对编程，共同解决问题！

### 边做边学

由于你的最终目标是提高 Rust 编程水平，因此编程经验至关重要。无论你从哪些资源或多少资源中学习，你都需要将学习付诸实践。然而，找到一个好的起点可能并非易事，因此我在这里提供一些建议。

&nbsp;&nbsp;&nbsp;&nbsp;在深入探讨这份清单之前，我想先提供一些关于如何选择项目的通用指导。首先，选择一个你真正感兴趣的项目，而不必过于担心其他人是否关注它。虽然有很多热门且成熟的 Rust 项目都希望你成为贡献者，而且能够说“我为知名的 X 库做出了贡献”也很有意思，但你的首要任务必须是你自己的兴趣。如果没有具体的动力，你很快就会失去动力，觉得贡献是一件苦差事。最好的目标是那些你自己使用过并且遇到过问题的项目——去解决它们吧！没有什么比摆脱长期困扰你的个人问题并回馈社区更令人满足的了。

&nbsp;&nbsp;&nbsp;&nbsp;好的，回到项目建议。首先，请考虑为 Rust 编译器及其相关工具做出贡献。它是一个高质量的代码库，拥有完善的文档和丰富的问题（你可能自己也知道一些），并且有几位优秀的导师可以提供解决问题的思路。如果你查看问题跟踪器中标记为“E-easy”或“E-mentor”的问题，你很可能很快就会找到合适的候选人。随着经验的积累，你可以不断提升，为更棘手的部分做出贡献。

&nbsp;&nbsp;&nbsp;&nbsp;如果这不合你的口味，我建议你找一些你经常使用的其他语言编写的代码，然后将其移植到 Rust 中——不一定非要替换原来的库或工具，而只是因为这种经验能让你专注于编写 Rust，而不必花费太多时间自己构思所有功能。如果移植效果良好，那么它的存在本身就表明其他人也需要它，所以你的移植也可能有更广泛的受众！数据结构和命令行工具通常是很好的移植主题，但你需要找到一个适合你的领域。

&nbsp;&nbsp;&nbsp;&nbsp;如果你更喜欢“从头开始构建”，我建议你回顾一下迄今为止的开发经历，并思考你在多个项目中（无论是用 Rust 还是其他语言）编写的类似代码。这种重复往往是一个好信号，表明某些代码是可重用的，可以转化为库。如果你什么也想不起来，David Tolnay 在 https://github.com/dtolnay/request-forimplementation/ 上维护了一个小型实用程序 `crate` 列表，这些 `crate` 是其他 Rust 开发者请求的，或许能给你一些灵感。如果你正在寻找一些更实质性、更雄心勃勃的东西，也可以访问 https://github.com/not-yet-awesome-rust/not-yet-awesome-rust/ 上的“尚未完善”列表，其中列出了 Rust 中应该存在但尚未实现的东西。

### 通过阅读学习

尽管情况正在不断改善，但找到适合初学者水平的优质 Rust 阅读材料仍然很困难。这里收集了一些我最喜欢的资源，它们不断地教会我新东西，或者在我遇到特别小众或细致的问题时，可以作为很好的参考。

&nbsp;&nbsp;&nbsp;&nbsp;首先，我建议你浏览一下 https://www.rust-lang.org/learn/ 链接中的官方 Rust 虚拟书籍。有些书籍，比如 Cargo 书籍，更像参考书；而有些书籍，比如 Embedded 书籍，更像指南，但它们都是各自主题的深度技术信息来源。尤其是 Rustonomicon (https://doc.rust-lang.org/nomicon/)，当你编写不安全的代码时，它简直就是救星。

&nbsp;&nbsp;&nbsp;&nbsp;另外两本值得一读的书是《Rustc 开发指南》（https://rustc-dev-guide.rust-lang.org/）和《标准库开发者指南》（https://std-dev-guide.rust-lang.org/）。如果你对 Rust 编译器的工作原理、标准库的设计方式感兴趣，或者想在尝试为 Rust 贡献代码之前获得一些指导，那么这些书都是非常棒的资源。Rust 官方指南也是信息宝库；我在书中已经提到过《Rust API 指南》（https://rust-lang.github.io/api-guidelines/），但《Rust 不安全代码指南参考》（https://rust-lang.github.io/unsafe-code-guidelines/）也已提供，当你读完本书时，可能会发现更多相关内容。

> https://www.rust-lang.org/learn/ 上列出的资源之一是 Rust参考，它本质上是 Rust 语言的完整规范。虽然其中有些部分内容比较枯燥，例如用于解析的具体语法或原始类型的内存表示的基础知识，但有些部分读起来却非常有趣，例如关于类型布局和未定义行为枚举的部分。

&nbsp;&nbsp;&nbsp;&nbsp;还有许多非官方的 Rust 虚拟书籍，它们汇集了宝贵的经验和知识。例如，如果你想编写非同寻常的声明式宏，《Rust 宏小书》（https://veykril.github.io/tlborm/）就是必不可少的；《Rust 性能手册》（https://nnethercote.github.io/perf-book/）则充满了在微观和宏观层面提升 Rust 代码性能的技巧和窍门。其他优秀的资源包括《Rust Fuzz 手册》（https://rust-fuzz.github.io/book/），它更详细地探讨了模糊测试；以及《Rust 食谱》（https://rust-lang-nursery.github.io/rust-cookbook/），它为常见的编程任务提供了惯用的解决方案。甚至还有一个资源可以帮你找到更多书籍，那就是《Rust 书籍小书》（https://lborb.github.io/book/unofficial.html）！

&nbsp;&nbsp;&nbsp;&nbsp;如果您更喜欢亲自动手的阅读，`Tokio` 项目发布了 `mini-redis` (https://github.com/tokio-rs/mini-redis/)，这是一个不完整但符合语言习惯的 Redis 客户端和服务器实现，它拥有极其详尽的文档，专门用于指导您编写异步代码。如果您更偏爱数据结构，那么《用太多链表学习 Rust》(https://rust-unofficial.github.io/too-many-lists/) 是一本富有启发性和趣味性的读物，深入探讨了所有权和引用的诸多细节。如果您正在寻找更贴近硬件的内容，Philipp Oppermann 的《用 Rust 编写操作系统》(https://os.phil-opp.com/) 不仅详细介绍了整个操作系统堆栈，还教会了您一些实用的 Rust 模式。如果你想广泛地阅读以对话风格撰写的有趣深度探讨文章，我也强烈推荐 Amos 的文章集 (https://fasterthanli.me/tags/rust/)。

&nbsp;&nbsp;&nbsp;&nbsp;当你对自己的 Rust 技能更有信心，并且需要的不仅仅是冗长的教程，还有快速参考，我发现 Rust 语言速查表 (https://cheats.rs/) 非常适合快速查找。它还为大多数主题提供了非常清晰的可视化解释，即使你查找的内容你并不熟悉，这些解释也非常容易理解。

&nbsp;&nbsp;&nbsp;&nbsp;最后，如果你想测试一下你对 Rust 的理解，不妨试试 David Tolnay 的 Rust 测验 (https://dtolnay.github.io/rust-quiz/)。里面有一些非常烧脑的题目，但每个问题都附有详尽的解释，所以即使你答错了一个，你也会从中吸取教训！

### 通过教学来学习

我的经验是，到目前为止，想要学好并彻底掌握一门语言，最好的方法就是尝试把它教给别人。我从写这本书中学到了很多，而且每次制作新的 Rust 视频或播客节目时，我都会学到新的东西。所以，我诚挚地建议你尝试将你从阅读本书中学到的，或者从现在开始学到的东西教给别人。你可以采取任何你喜欢的形式：面对面交流、撰写博客文章、发推文、制作视频或播客，或者进行演讲。重要的是，你要尝试用你自己的语言将你新学到的知识传达给那些还不了解这个主题的人——这样做，你也回馈了社区，这样下一个你就能更容易地跟上进度。教学是一种令人谦卑且具有深刻教育意义的经历，我强烈推荐它。

> 无论您是想教学还是受教，请务必访问 Awesome Rust Mentors (https://rustbeginners.github.io/awesome-rust-mentors/)。

## 总结

在本章中，我们探讨了 Rust 的更多内容，而不仅仅是本地工作区中的内容。我们概述了实用的工具、库和 Rust 特性；探讨了如何在 Rust 生态系统不断发展的同时保持最新状态；然后讨论了如何亲自动手，为 Rust 生态系统做出贡献。最后，我们讨论了本书即将结束，您可以如何继续您的 Rust 之旅。至此，除了声明之外，我们几乎没有什么要做的


















